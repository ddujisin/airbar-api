# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _NotificationTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.NotificationType']]


class _NotificationTypeListFilterHasInput(TypedDict):
    has: 'enums.NotificationType'


class _NotificationTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.NotificationType']


class _NotificationTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.NotificationType']


class _NotificationTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


NotificationTypeListFilter = Union[
    _NotificationTypeListFilterHasInput,
    _NotificationTypeListFilterEqualsInput,
    _NotificationTypeListFilterHasSomeInput,
    _NotificationTypeListFilterIsEmptyInput,
    _NotificationTypeListFilterHasEveryInput,
]


class _NotificationTypeListUpdateSet(TypedDict):
    set: List['enums.NotificationType']


class _NotificationTypeListUpdatePush(TypedDict):
    push: List['enums.NotificationType']


NotificationTypeListUpdate = Union[
    List['enums.NotificationType'],
    _NotificationTypeListUpdateSet,
    _NotificationTypeListUpdatePush,
]

class _NotificationChannelListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.NotificationChannel']]


class _NotificationChannelListFilterHasInput(TypedDict):
    has: 'enums.NotificationChannel'


class _NotificationChannelListFilterHasEveryInput(TypedDict):
    has_every: List['enums.NotificationChannel']


class _NotificationChannelListFilterHasSomeInput(TypedDict):
    has_some: List['enums.NotificationChannel']


class _NotificationChannelListFilterIsEmptyInput(TypedDict):
    is_empty: bool


NotificationChannelListFilter = Union[
    _NotificationChannelListFilterHasInput,
    _NotificationChannelListFilterEqualsInput,
    _NotificationChannelListFilterHasSomeInput,
    _NotificationChannelListFilterIsEmptyInput,
    _NotificationChannelListFilterHasEveryInput,
]


class _NotificationChannelListUpdateSet(TypedDict):
    set: List['enums.NotificationChannel']


class _NotificationChannelListUpdatePush(TypedDict):
    push: List['enums.NotificationChannel']


NotificationChannelListUpdate = Union[
    List['enums.NotificationChannel'],
    _NotificationChannelListUpdateSet,
    _NotificationChannelListUpdatePush,
]


# Admin types

class AdminOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Admin create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AdminCreateInput(AdminOptionalCreateInput):
    """Required arguments to the Admin create method"""
    email: _str
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AdminOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Admin create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AdminCreateWithoutRelationsInput(AdminOptionalCreateWithoutRelationsInput):
    """Required arguments to the Admin create method, without relations"""
    email: _str
    password: _str

class AdminConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AdminCreateWithoutRelationsInput'
    where: 'AdminWhereUniqueInput'

class AdminCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AdminCreateWithoutRelationsInput'
    connect: 'AdminWhereUniqueInput'
    connect_or_create: 'AdminConnectOrCreateWithoutRelationsInput'


class AdminCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AdminCreateWithoutRelationsInput', List['AdminCreateWithoutRelationsInput']]
    connect: Union['AdminWhereUniqueInput', List['AdminWhereUniqueInput']]
    connect_or_create: Union['AdminConnectOrCreateWithoutRelationsInput', List['AdminConnectOrCreateWithoutRelationsInput']]

_AdminWhereUnique_id_Input = TypedDict(
    '_AdminWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_AdminWhereUnique_email_Input = TypedDict(
    '_AdminWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

AdminWhereUniqueInput = Union[
    '_AdminWhereUnique_id_Input',
    '_AdminWhereUnique_email_Input',
]


class AdminUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    email: _str
    password: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AdminUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    email: _str
    password: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AdminUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AdminCreateWithoutRelationsInput']
    connect: List['AdminWhereUniqueInput']
    connect_or_create: List['AdminConnectOrCreateWithoutRelationsInput']
    set: List['AdminWhereUniqueInput']
    disconnect: List['AdminWhereUniqueInput']
    delete: List['AdminWhereUniqueInput']

    # TODO
    # update: List['AdminUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AdminUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AdminScalarWhereInput']
    # upsert: List['AdminUpserteWithWhereUniqueWithoutRelationsInput']


class AdminUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AdminCreateWithoutRelationsInput'
    connect: 'AdminWhereUniqueInput'
    connect_or_create: 'AdminConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AdminUpdateInput'
    # upsert: 'AdminUpsertWithoutRelationsInput'


class AdminUpsertInput(TypedDict):
    create: 'AdminCreateInput'
    update: 'AdminUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Admin_id_OrderByInput = TypedDict(
    '_Admin_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Admin_email_OrderByInput = TypedDict(
    '_Admin_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Admin_password_OrderByInput = TypedDict(
    '_Admin_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_Admin_createdAt_OrderByInput = TypedDict(
    '_Admin_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Admin_updatedAt_OrderByInput = TypedDict(
    '_Admin_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Admin_RelevanceInner = TypedDict(
    '_Admin_RelevanceInner',
    {
        'fields': 'List[AdminScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Admin_RelevanceOrderByInput = TypedDict(
    '_Admin_RelevanceOrderByInput',
    {
        '_relevance': '_Admin_RelevanceInner',
    },
    total=True
)

AdminOrderByInput = Union[
    '_Admin_id_OrderByInput',
    '_Admin_email_OrderByInput',
    '_Admin_password_OrderByInput',
    '_Admin_createdAt_OrderByInput',
    '_Admin_updatedAt_OrderByInput',
    '_Admin_RelevanceOrderByInput',
]



# recursive Admin types
# TODO: cleanup these types



AdminRelationFilter = TypedDict(
    'AdminRelationFilter',
    {
        'is': 'AdminWhereInput',
        'is_not': 'AdminWhereInput',
    },
    total=False,
)


class AdminListRelationFilter(TypedDict, total=False):
    some: 'AdminWhereInput'
    none: 'AdminWhereInput'
    every: 'AdminWhereInput'


class AdminInclude(TypedDict, total=False):
    """Admin relational arguments"""


class AdminIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""


class AdminArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    reservations: Union[bool, 'FindManyReservationArgsFromAdmin']


class GuestArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    guest: Union[bool, 'GuestArgsFromAdmin']
    orders: Union[bool, 'FindManyOrderArgsFromAdmin']
    payments: Union[bool, 'FindManyPaymentArgsFromAdmin']


class ReservationArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromAdmin']


class ItemArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    reservation: Union[bool, 'ReservationArgsFromAdmin']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromAdmin']
    payment: Union[bool, 'PaymentArgsFromAdmin']


class OrderArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    order: Union[bool, 'OrderArgsFromAdmin']
    item: Union[bool, 'ItemArgsFromAdmin']


class OrderItemArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    reservation: Union[bool, 'ReservationArgsFromAdmin']
    orders: Union[bool, 'FindManyOrderArgsFromAdmin']


class PaymentArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""


class NotificationPreferenceArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""


class NotificationArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyAdminArgs = FindManyAdminArgsFromAdmin
FindFirstAdminArgs = FindManyAdminArgsFromAdmin


class AdminWhereInput(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AdminWhereInput', List['AdminWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AdminWhereInput']
    OR: List['AdminWhereInput']
    NOT: List['AdminWhereInput']



# aggregate Admin types


class AdminScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AdminScalarWhereWithAggregatesInput']
    OR: List['AdminScalarWhereWithAggregatesInput']
    NOT: List['AdminScalarWhereWithAggregatesInput']



class AdminGroupByOutput(TypedDict, total=False):
    id: _str
    email: _str
    password: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'AdminSumAggregateOutput'
    _avg: 'AdminAvgAggregateOutput'
    _min: 'AdminMinAggregateOutput'
    _max: 'AdminMaxAggregateOutput'
    _count: 'AdminCountAggregateOutput'


class AdminAvgAggregateOutput(TypedDict, total=False):
    """Admin output for aggregating averages"""


class AdminSumAggregateOutput(TypedDict, total=False):
    """Admin output for aggregating sums"""


class AdminScalarAggregateOutput(TypedDict, total=False):
    """Admin output including scalar fields"""
    id: _str
    email: _str
    password: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


AdminMinAggregateOutput = AdminScalarAggregateOutput
AdminMaxAggregateOutput = AdminScalarAggregateOutput


class AdminMaxAggregateInput(TypedDict, total=False):
    """Admin input for aggregating by max"""
    id: bool
    email: bool
    password: bool
    createdAt: bool
    updatedAt: bool


class AdminMinAggregateInput(TypedDict, total=False):
    """Admin input for aggregating by min"""
    id: bool
    email: bool
    password: bool
    createdAt: bool
    updatedAt: bool


class AdminNumberAggregateInput(TypedDict, total=False):
    """Admin input for aggregating numbers"""


AdminAvgAggregateInput = AdminNumberAggregateInput
AdminSumAggregateInput = AdminNumberAggregateInput


AdminCountAggregateInput = TypedDict(
    'AdminCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'password': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

AdminCountAggregateOutput = TypedDict(
    'AdminCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'password': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


AdminKeys = Literal[
    'id',
    'email',
    'password',
    'createdAt',
    'updatedAt',
]
AdminScalarFieldKeys = Literal[
    'id',
    'email',
    'password',
    'createdAt',
    'updatedAt',
]
AdminScalarFieldKeysT = TypeVar('AdminScalarFieldKeysT', bound=AdminScalarFieldKeys)

AdminRelationalFieldKeys = _NoneType

# Guest types

class GuestOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Guest create method"""
    id: _str
    phoneNumber: Optional[_str]
    preferences: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    reservations: 'ReservationCreateManyNestedWithoutRelationsInput'


class GuestCreateInput(GuestOptionalCreateInput):
    """Required arguments to the Guest create method"""
    name: _str
    email: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class GuestOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Guest create method, without relations"""
    id: _str
    phoneNumber: Optional[_str]
    preferences: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class GuestCreateWithoutRelationsInput(GuestOptionalCreateWithoutRelationsInput):
    """Required arguments to the Guest create method, without relations"""
    name: _str
    email: _str

class GuestConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'GuestCreateWithoutRelationsInput'
    where: 'GuestWhereUniqueInput'

class GuestCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'GuestCreateWithoutRelationsInput'
    connect: 'GuestWhereUniqueInput'
    connect_or_create: 'GuestConnectOrCreateWithoutRelationsInput'


class GuestCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['GuestCreateWithoutRelationsInput', List['GuestCreateWithoutRelationsInput']]
    connect: Union['GuestWhereUniqueInput', List['GuestWhereUniqueInput']]
    connect_or_create: Union['GuestConnectOrCreateWithoutRelationsInput', List['GuestConnectOrCreateWithoutRelationsInput']]

_GuestWhereUnique_id_Input = TypedDict(
    '_GuestWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_GuestWhereUnique_email_Input = TypedDict(
    '_GuestWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

GuestWhereUniqueInput = Union[
    '_GuestWhereUnique_id_Input',
    '_GuestWhereUnique_email_Input',
]


class GuestUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    email: _str
    phoneNumber: Optional[_str]
    preferences: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    reservations: 'ReservationUpdateManyWithoutRelationsInput'


class GuestUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    email: _str
    phoneNumber: Optional[_str]
    preferences: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class GuestUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['GuestCreateWithoutRelationsInput']
    connect: List['GuestWhereUniqueInput']
    connect_or_create: List['GuestConnectOrCreateWithoutRelationsInput']
    set: List['GuestWhereUniqueInput']
    disconnect: List['GuestWhereUniqueInput']
    delete: List['GuestWhereUniqueInput']

    # TODO
    # update: List['GuestUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['GuestUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['GuestScalarWhereInput']
    # upsert: List['GuestUpserteWithWhereUniqueWithoutRelationsInput']


class GuestUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'GuestCreateWithoutRelationsInput'
    connect: 'GuestWhereUniqueInput'
    connect_or_create: 'GuestConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'GuestUpdateInput'
    # upsert: 'GuestUpsertWithoutRelationsInput'


class GuestUpsertInput(TypedDict):
    create: 'GuestCreateInput'
    update: 'GuestUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Guest_id_OrderByInput = TypedDict(
    '_Guest_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Guest_name_OrderByInput = TypedDict(
    '_Guest_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Guest_email_OrderByInput = TypedDict(
    '_Guest_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Guest_phoneNumber_OrderByInput = TypedDict(
    '_Guest_phoneNumber_OrderByInput',
    {
        'phoneNumber': 'SortOrder',
    },
    total=True
)

_Guest_preferences_OrderByInput = TypedDict(
    '_Guest_preferences_OrderByInput',
    {
        'preferences': 'SortOrder',
    },
    total=True
)

_Guest_createdAt_OrderByInput = TypedDict(
    '_Guest_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Guest_updatedAt_OrderByInput = TypedDict(
    '_Guest_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Guest_RelevanceInner = TypedDict(
    '_Guest_RelevanceInner',
    {
        'fields': 'List[GuestScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Guest_RelevanceOrderByInput = TypedDict(
    '_Guest_RelevanceOrderByInput',
    {
        '_relevance': '_Guest_RelevanceInner',
    },
    total=True
)

GuestOrderByInput = Union[
    '_Guest_id_OrderByInput',
    '_Guest_name_OrderByInput',
    '_Guest_email_OrderByInput',
    '_Guest_phoneNumber_OrderByInput',
    '_Guest_preferences_OrderByInput',
    '_Guest_createdAt_OrderByInput',
    '_Guest_updatedAt_OrderByInput',
    '_Guest_RelevanceOrderByInput',
]



# recursive Guest types
# TODO: cleanup these types



GuestRelationFilter = TypedDict(
    'GuestRelationFilter',
    {
        'is': 'GuestWhereInput',
        'is_not': 'GuestWhereInput',
    },
    total=False,
)


class GuestListRelationFilter(TypedDict, total=False):
    some: 'GuestWhereInput'
    none: 'GuestWhereInput'
    every: 'GuestWhereInput'


class GuestInclude(TypedDict, total=False):
    """Guest relational arguments"""
    reservations: Union[bool, 'FindManyReservationArgsFromGuest']


class AdminIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""


class AdminArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""
    reservations: Union[bool, 'FindManyReservationArgsFromGuest']


class GuestArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""
    guest: Union[bool, 'GuestArgsFromGuest']
    orders: Union[bool, 'FindManyOrderArgsFromGuest']
    payments: Union[bool, 'FindManyPaymentArgsFromGuest']


class ReservationArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromGuest']


class ItemArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""
    reservation: Union[bool, 'ReservationArgsFromGuest']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromGuest']
    payment: Union[bool, 'PaymentArgsFromGuest']


class OrderArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""
    order: Union[bool, 'OrderArgsFromGuest']
    item: Union[bool, 'ItemArgsFromGuest']


class OrderItemArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""
    reservation: Union[bool, 'ReservationArgsFromGuest']
    orders: Union[bool, 'FindManyOrderArgsFromGuest']


class PaymentArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""


class NotificationPreferenceArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromGuest(TypedDict, total=False):
    """Relational arguments for Guest"""


class NotificationArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromGuest(TypedDict, total=False):
    """Arguments for Guest"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyGuestArgs = FindManyGuestArgsFromGuest
FindFirstGuestArgs = FindManyGuestArgsFromGuest


class GuestWhereInput(TypedDict, total=False):
    """Guest arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phoneNumber: Union[None, _str, 'types.StringFilter']
    preferences: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    reservations: 'ReservationListRelationFilter'

    # should be noted that AND and NOT should be Union['GuestWhereInput', List['GuestWhereInput']]
    # but this causes mypy to hang :/
    AND: List['GuestWhereInput']
    OR: List['GuestWhereInput']
    NOT: List['GuestWhereInput']



# aggregate Guest types


class GuestScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Guest arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phoneNumber: Union[_str, 'types.StringWithAggregatesFilter']
    preferences: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['GuestScalarWhereWithAggregatesInput']
    OR: List['GuestScalarWhereWithAggregatesInput']
    NOT: List['GuestScalarWhereWithAggregatesInput']



class GuestGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    email: _str
    phoneNumber: _str
    preferences: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'GuestSumAggregateOutput'
    _avg: 'GuestAvgAggregateOutput'
    _min: 'GuestMinAggregateOutput'
    _max: 'GuestMaxAggregateOutput'
    _count: 'GuestCountAggregateOutput'


class GuestAvgAggregateOutput(TypedDict, total=False):
    """Guest output for aggregating averages"""


class GuestSumAggregateOutput(TypedDict, total=False):
    """Guest output for aggregating sums"""


class GuestScalarAggregateOutput(TypedDict, total=False):
    """Guest output including scalar fields"""
    id: _str
    name: _str
    email: _str
    phoneNumber: _str
    preferences: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


GuestMinAggregateOutput = GuestScalarAggregateOutput
GuestMaxAggregateOutput = GuestScalarAggregateOutput


class GuestMaxAggregateInput(TypedDict, total=False):
    """Guest input for aggregating by max"""
    id: bool
    name: bool
    email: bool
    phoneNumber: bool
    preferences: bool
    createdAt: bool
    updatedAt: bool


class GuestMinAggregateInput(TypedDict, total=False):
    """Guest input for aggregating by min"""
    id: bool
    name: bool
    email: bool
    phoneNumber: bool
    preferences: bool
    createdAt: bool
    updatedAt: bool


class GuestNumberAggregateInput(TypedDict, total=False):
    """Guest input for aggregating numbers"""


GuestAvgAggregateInput = GuestNumberAggregateInput
GuestSumAggregateInput = GuestNumberAggregateInput


GuestCountAggregateInput = TypedDict(
    'GuestCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'email': bool,
        'phoneNumber': bool,
        'preferences': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

GuestCountAggregateOutput = TypedDict(
    'GuestCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'email': int,
        'phoneNumber': int,
        'preferences': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


GuestKeys = Literal[
    'id',
    'name',
    'email',
    'phoneNumber',
    'preferences',
    'createdAt',
    'updatedAt',
    'reservations',
]
GuestScalarFieldKeys = Literal[
    'id',
    'name',
    'email',
    'phoneNumber',
    'preferences',
    'createdAt',
    'updatedAt',
]
GuestScalarFieldKeysT = TypeVar('GuestScalarFieldKeysT', bound=GuestScalarFieldKeys)

GuestRelationalFieldKeys = Literal[
        'reservations',
    ]

# Reservation types

class ReservationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Reservation create method"""
    id: _str
    status: _str
    roomNumber: Optional[_str]
    guestId: _str
    guest: 'GuestCreateNestedWithoutRelationsInput'
    orders: 'OrderCreateManyNestedWithoutRelationsInput'
    payments: 'PaymentCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReservationCreateInput(ReservationOptionalCreateInput):
    """Required arguments to the Reservation create method"""
    startDate: datetime.datetime
    endDate: datetime.datetime
    pinCode: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ReservationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Reservation create method, without relations"""
    id: _str
    status: _str
    roomNumber: Optional[_str]
    guestId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReservationCreateWithoutRelationsInput(ReservationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Reservation create method, without relations"""
    startDate: datetime.datetime
    endDate: datetime.datetime
    pinCode: _str

class ReservationConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ReservationCreateWithoutRelationsInput'
    where: 'ReservationWhereUniqueInput'

class ReservationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ReservationCreateWithoutRelationsInput'
    connect: 'ReservationWhereUniqueInput'
    connect_or_create: 'ReservationConnectOrCreateWithoutRelationsInput'


class ReservationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ReservationCreateWithoutRelationsInput', List['ReservationCreateWithoutRelationsInput']]
    connect: Union['ReservationWhereUniqueInput', List['ReservationWhereUniqueInput']]
    connect_or_create: Union['ReservationConnectOrCreateWithoutRelationsInput', List['ReservationConnectOrCreateWithoutRelationsInput']]

_ReservationWhereUnique_id_Input = TypedDict(
    '_ReservationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ReservationWhereUnique_pinCode_Input = TypedDict(
    '_ReservationWhereUnique_pinCode_Input',
    {
        'pinCode': '_str',
    },
    total=True
)

ReservationWhereUniqueInput = Union[
    '_ReservationWhereUnique_id_Input',
    '_ReservationWhereUnique_pinCode_Input',
]


class ReservationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    pinCode: _str
    status: _str
    roomNumber: Optional[_str]
    guest: 'GuestUpdateOneWithoutRelationsInput'
    orders: 'OrderUpdateManyWithoutRelationsInput'
    payments: 'PaymentUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReservationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    pinCode: _str
    status: _str
    roomNumber: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReservationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ReservationCreateWithoutRelationsInput']
    connect: List['ReservationWhereUniqueInput']
    connect_or_create: List['ReservationConnectOrCreateWithoutRelationsInput']
    set: List['ReservationWhereUniqueInput']
    disconnect: List['ReservationWhereUniqueInput']
    delete: List['ReservationWhereUniqueInput']

    # TODO
    # update: List['ReservationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ReservationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ReservationScalarWhereInput']
    # upsert: List['ReservationUpserteWithWhereUniqueWithoutRelationsInput']


class ReservationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ReservationCreateWithoutRelationsInput'
    connect: 'ReservationWhereUniqueInput'
    connect_or_create: 'ReservationConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ReservationUpdateInput'
    # upsert: 'ReservationUpsertWithoutRelationsInput'


class ReservationUpsertInput(TypedDict):
    create: 'ReservationCreateInput'
    update: 'ReservationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Reservation_id_OrderByInput = TypedDict(
    '_Reservation_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Reservation_startDate_OrderByInput = TypedDict(
    '_Reservation_startDate_OrderByInput',
    {
        'startDate': 'SortOrder',
    },
    total=True
)

_Reservation_endDate_OrderByInput = TypedDict(
    '_Reservation_endDate_OrderByInput',
    {
        'endDate': 'SortOrder',
    },
    total=True
)

_Reservation_pinCode_OrderByInput = TypedDict(
    '_Reservation_pinCode_OrderByInput',
    {
        'pinCode': 'SortOrder',
    },
    total=True
)

_Reservation_status_OrderByInput = TypedDict(
    '_Reservation_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Reservation_roomNumber_OrderByInput = TypedDict(
    '_Reservation_roomNumber_OrderByInput',
    {
        'roomNumber': 'SortOrder',
    },
    total=True
)

_Reservation_guestId_OrderByInput = TypedDict(
    '_Reservation_guestId_OrderByInput',
    {
        'guestId': 'SortOrder',
    },
    total=True
)

_Reservation_createdAt_OrderByInput = TypedDict(
    '_Reservation_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Reservation_updatedAt_OrderByInput = TypedDict(
    '_Reservation_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Reservation_RelevanceInner = TypedDict(
    '_Reservation_RelevanceInner',
    {
        'fields': 'List[ReservationScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Reservation_RelevanceOrderByInput = TypedDict(
    '_Reservation_RelevanceOrderByInput',
    {
        '_relevance': '_Reservation_RelevanceInner',
    },
    total=True
)

ReservationOrderByInput = Union[
    '_Reservation_id_OrderByInput',
    '_Reservation_startDate_OrderByInput',
    '_Reservation_endDate_OrderByInput',
    '_Reservation_pinCode_OrderByInput',
    '_Reservation_status_OrderByInput',
    '_Reservation_roomNumber_OrderByInput',
    '_Reservation_guestId_OrderByInput',
    '_Reservation_createdAt_OrderByInput',
    '_Reservation_updatedAt_OrderByInput',
    '_Reservation_RelevanceOrderByInput',
]



# recursive Reservation types
# TODO: cleanup these types



ReservationRelationFilter = TypedDict(
    'ReservationRelationFilter',
    {
        'is': 'ReservationWhereInput',
        'is_not': 'ReservationWhereInput',
    },
    total=False,
)


class ReservationListRelationFilter(TypedDict, total=False):
    some: 'ReservationWhereInput'
    none: 'ReservationWhereInput'
    every: 'ReservationWhereInput'


class ReservationInclude(TypedDict, total=False):
    """Reservation relational arguments"""
    guest: Union[bool, 'GuestArgsFromReservation']
    orders: Union[bool, 'FindManyOrderArgsFromReservation']
    payments: Union[bool, 'FindManyPaymentArgsFromReservation']


class AdminIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""


class AdminArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""
    reservations: Union[bool, 'FindManyReservationArgsFromReservation']


class GuestArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""
    guest: Union[bool, 'GuestArgsFromReservation']
    orders: Union[bool, 'FindManyOrderArgsFromReservation']
    payments: Union[bool, 'FindManyPaymentArgsFromReservation']


class ReservationArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromReservation']


class ItemArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""
    reservation: Union[bool, 'ReservationArgsFromReservation']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromReservation']
    payment: Union[bool, 'PaymentArgsFromReservation']


class OrderArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""
    order: Union[bool, 'OrderArgsFromReservation']
    item: Union[bool, 'ItemArgsFromReservation']


class OrderItemArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""
    reservation: Union[bool, 'ReservationArgsFromReservation']
    orders: Union[bool, 'FindManyOrderArgsFromReservation']


class PaymentArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""


class NotificationPreferenceArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromReservation(TypedDict, total=False):
    """Relational arguments for Reservation"""


class NotificationArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromReservation(TypedDict, total=False):
    """Arguments for Reservation"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyReservationArgs = FindManyReservationArgsFromReservation
FindFirstReservationArgs = FindManyReservationArgsFromReservation


class ReservationWhereInput(TypedDict, total=False):
    """Reservation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    pinCode: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    roomNumber: Union[None, _str, 'types.StringFilter']
    guestId: Union[_str, 'types.StringFilter']
    guest: 'GuestRelationFilter'
    orders: 'OrderListRelationFilter'
    payments: 'PaymentListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ReservationWhereInput', List['ReservationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ReservationWhereInput']
    OR: List['ReservationWhereInput']
    NOT: List['ReservationWhereInput']



# aggregate Reservation types


class ReservationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Reservation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    pinCode: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    roomNumber: Union[_str, 'types.StringWithAggregatesFilter']
    guestId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReservationScalarWhereWithAggregatesInput']
    OR: List['ReservationScalarWhereWithAggregatesInput']
    NOT: List['ReservationScalarWhereWithAggregatesInput']



class ReservationGroupByOutput(TypedDict, total=False):
    id: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    pinCode: _str
    status: _str
    roomNumber: _str
    guestId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ReservationSumAggregateOutput'
    _avg: 'ReservationAvgAggregateOutput'
    _min: 'ReservationMinAggregateOutput'
    _max: 'ReservationMaxAggregateOutput'
    _count: 'ReservationCountAggregateOutput'


class ReservationAvgAggregateOutput(TypedDict, total=False):
    """Reservation output for aggregating averages"""


class ReservationSumAggregateOutput(TypedDict, total=False):
    """Reservation output for aggregating sums"""


class ReservationScalarAggregateOutput(TypedDict, total=False):
    """Reservation output including scalar fields"""
    id: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    pinCode: _str
    status: _str
    roomNumber: _str
    guestId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ReservationMinAggregateOutput = ReservationScalarAggregateOutput
ReservationMaxAggregateOutput = ReservationScalarAggregateOutput


class ReservationMaxAggregateInput(TypedDict, total=False):
    """Reservation input for aggregating by max"""
    id: bool
    startDate: bool
    endDate: bool
    pinCode: bool
    status: bool
    roomNumber: bool
    guestId: bool
    createdAt: bool
    updatedAt: bool


class ReservationMinAggregateInput(TypedDict, total=False):
    """Reservation input for aggregating by min"""
    id: bool
    startDate: bool
    endDate: bool
    pinCode: bool
    status: bool
    roomNumber: bool
    guestId: bool
    createdAt: bool
    updatedAt: bool


class ReservationNumberAggregateInput(TypedDict, total=False):
    """Reservation input for aggregating numbers"""


ReservationAvgAggregateInput = ReservationNumberAggregateInput
ReservationSumAggregateInput = ReservationNumberAggregateInput


ReservationCountAggregateInput = TypedDict(
    'ReservationCountAggregateInput',
    {
        'id': bool,
        'startDate': bool,
        'endDate': bool,
        'pinCode': bool,
        'status': bool,
        'roomNumber': bool,
        'guestId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ReservationCountAggregateOutput = TypedDict(
    'ReservationCountAggregateOutput',
    {
        'id': int,
        'startDate': int,
        'endDate': int,
        'pinCode': int,
        'status': int,
        'roomNumber': int,
        'guestId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ReservationKeys = Literal[
    'id',
    'startDate',
    'endDate',
    'pinCode',
    'status',
    'roomNumber',
    'guestId',
    'guest',
    'orders',
    'payments',
    'createdAt',
    'updatedAt',
]
ReservationScalarFieldKeys = Literal[
    'id',
    'startDate',
    'endDate',
    'pinCode',
    'status',
    'roomNumber',
    'guestId',
    'createdAt',
    'updatedAt',
]
ReservationScalarFieldKeysT = TypeVar('ReservationScalarFieldKeysT', bound=ReservationScalarFieldKeys)

ReservationRelationalFieldKeys = Literal[
        'guest',
        'orders',
        'payments',
    ]

# Item types

class ItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Item create method"""
    id: _str
    description: Optional[_str]
    category: Optional[_str]
    available: _bool
    stockLevel: _int
    imageUrl: Optional[_str]
    orderItems: 'OrderItemCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ItemCreateInput(ItemOptionalCreateInput):
    """Required arguments to the Item create method"""
    name: _str
    price: decimal.Decimal
    qrCode: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Item create method, without relations"""
    id: _str
    description: Optional[_str]
    category: Optional[_str]
    available: _bool
    stockLevel: _int
    imageUrl: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ItemCreateWithoutRelationsInput(ItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the Item create method, without relations"""
    name: _str
    price: decimal.Decimal
    qrCode: _str

class ItemConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ItemCreateWithoutRelationsInput'
    where: 'ItemWhereUniqueInput'

class ItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ItemCreateWithoutRelationsInput'
    connect: 'ItemWhereUniqueInput'
    connect_or_create: 'ItemConnectOrCreateWithoutRelationsInput'


class ItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ItemCreateWithoutRelationsInput', List['ItemCreateWithoutRelationsInput']]
    connect: Union['ItemWhereUniqueInput', List['ItemWhereUniqueInput']]
    connect_or_create: Union['ItemConnectOrCreateWithoutRelationsInput', List['ItemConnectOrCreateWithoutRelationsInput']]

_ItemWhereUnique_id_Input = TypedDict(
    '_ItemWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ItemWhereUnique_qrCode_Input = TypedDict(
    '_ItemWhereUnique_qrCode_Input',
    {
        'qrCode': '_str',
    },
    total=True
)

ItemWhereUniqueInput = Union[
    '_ItemWhereUnique_id_Input',
    '_ItemWhereUnique_qrCode_Input',
]


class ItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    price: decimal.Decimal
    qrCode: _str
    description: Optional[_str]
    category: Optional[_str]
    available: _bool
    stockLevel: Union[AtomicIntInput, _int]
    imageUrl: Optional[_str]
    orderItems: 'OrderItemUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    price: decimal.Decimal
    qrCode: _str
    description: Optional[_str]
    category: Optional[_str]
    available: _bool
    stockLevel: Union[AtomicIntInput, _int]
    imageUrl: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ItemCreateWithoutRelationsInput']
    connect: List['ItemWhereUniqueInput']
    connect_or_create: List['ItemConnectOrCreateWithoutRelationsInput']
    set: List['ItemWhereUniqueInput']
    disconnect: List['ItemWhereUniqueInput']
    delete: List['ItemWhereUniqueInput']

    # TODO
    # update: List['ItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ItemScalarWhereInput']
    # upsert: List['ItemUpserteWithWhereUniqueWithoutRelationsInput']


class ItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ItemCreateWithoutRelationsInput'
    connect: 'ItemWhereUniqueInput'
    connect_or_create: 'ItemConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ItemUpdateInput'
    # upsert: 'ItemUpsertWithoutRelationsInput'


class ItemUpsertInput(TypedDict):
    create: 'ItemCreateInput'
    update: 'ItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Item_id_OrderByInput = TypedDict(
    '_Item_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Item_name_OrderByInput = TypedDict(
    '_Item_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Item_price_OrderByInput = TypedDict(
    '_Item_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_Item_qrCode_OrderByInput = TypedDict(
    '_Item_qrCode_OrderByInput',
    {
        'qrCode': 'SortOrder',
    },
    total=True
)

_Item_description_OrderByInput = TypedDict(
    '_Item_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Item_category_OrderByInput = TypedDict(
    '_Item_category_OrderByInput',
    {
        'category': 'SortOrder',
    },
    total=True
)

_Item_available_OrderByInput = TypedDict(
    '_Item_available_OrderByInput',
    {
        'available': 'SortOrder',
    },
    total=True
)

_Item_stockLevel_OrderByInput = TypedDict(
    '_Item_stockLevel_OrderByInput',
    {
        'stockLevel': 'SortOrder',
    },
    total=True
)

_Item_imageUrl_OrderByInput = TypedDict(
    '_Item_imageUrl_OrderByInput',
    {
        'imageUrl': 'SortOrder',
    },
    total=True
)

_Item_createdAt_OrderByInput = TypedDict(
    '_Item_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Item_updatedAt_OrderByInput = TypedDict(
    '_Item_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Item_RelevanceInner = TypedDict(
    '_Item_RelevanceInner',
    {
        'fields': 'List[ItemScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Item_RelevanceOrderByInput = TypedDict(
    '_Item_RelevanceOrderByInput',
    {
        '_relevance': '_Item_RelevanceInner',
    },
    total=True
)

ItemOrderByInput = Union[
    '_Item_id_OrderByInput',
    '_Item_name_OrderByInput',
    '_Item_price_OrderByInput',
    '_Item_qrCode_OrderByInput',
    '_Item_description_OrderByInput',
    '_Item_category_OrderByInput',
    '_Item_available_OrderByInput',
    '_Item_stockLevel_OrderByInput',
    '_Item_imageUrl_OrderByInput',
    '_Item_createdAt_OrderByInput',
    '_Item_updatedAt_OrderByInput',
    '_Item_RelevanceOrderByInput',
]



# recursive Item types
# TODO: cleanup these types



ItemRelationFilter = TypedDict(
    'ItemRelationFilter',
    {
        'is': 'ItemWhereInput',
        'is_not': 'ItemWhereInput',
    },
    total=False,
)


class ItemListRelationFilter(TypedDict, total=False):
    some: 'ItemWhereInput'
    none: 'ItemWhereInput'
    every: 'ItemWhereInput'


class ItemInclude(TypedDict, total=False):
    """Item relational arguments"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromItem']


class AdminIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""


class AdminArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""
    reservations: Union[bool, 'FindManyReservationArgsFromItem']


class GuestArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""
    guest: Union[bool, 'GuestArgsFromItem']
    orders: Union[bool, 'FindManyOrderArgsFromItem']
    payments: Union[bool, 'FindManyPaymentArgsFromItem']


class ReservationArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromItem']


class ItemArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""
    reservation: Union[bool, 'ReservationArgsFromItem']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromItem']
    payment: Union[bool, 'PaymentArgsFromItem']


class OrderArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""
    order: Union[bool, 'OrderArgsFromItem']
    item: Union[bool, 'ItemArgsFromItem']


class OrderItemArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""
    reservation: Union[bool, 'ReservationArgsFromItem']
    orders: Union[bool, 'FindManyOrderArgsFromItem']


class PaymentArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""


class NotificationPreferenceArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromItem(TypedDict, total=False):
    """Relational arguments for Item"""


class NotificationArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromItem(TypedDict, total=False):
    """Arguments for Item"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyItemArgs = FindManyItemArgsFromItem
FindFirstItemArgs = FindManyItemArgsFromItem


class ItemWhereInput(TypedDict, total=False):
    """Item arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    price: Union[decimal.Decimal, 'types.DecimalFilter']
    qrCode: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[None, _str, 'types.StringFilter']
    available: Union[_bool, 'types.BooleanFilter']
    stockLevel: Union[_int, 'types.IntFilter']
    imageUrl: Union[None, _str, 'types.StringFilter']
    orderItems: 'OrderItemListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ItemWhereInput', List['ItemWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ItemWhereInput']
    OR: List['ItemWhereInput']
    NOT: List['ItemWhereInput']



# aggregate Item types


class ItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Item arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    price: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    qrCode: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    available: Union[_bool, 'types.BooleanWithAggregatesFilter']
    stockLevel: Union[_int, 'types.IntWithAggregatesFilter']
    imageUrl: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ItemScalarWhereWithAggregatesInput']
    OR: List['ItemScalarWhereWithAggregatesInput']
    NOT: List['ItemScalarWhereWithAggregatesInput']



class ItemGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    price: decimal.Decimal
    qrCode: _str
    description: _str
    category: _str
    available: _bool
    stockLevel: _int
    imageUrl: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ItemSumAggregateOutput'
    _avg: 'ItemAvgAggregateOutput'
    _min: 'ItemMinAggregateOutput'
    _max: 'ItemMaxAggregateOutput'
    _count: 'ItemCountAggregateOutput'


class ItemAvgAggregateOutput(TypedDict, total=False):
    """Item output for aggregating averages"""
    stockLevel: float


class ItemSumAggregateOutput(TypedDict, total=False):
    """Item output for aggregating sums"""
    stockLevel: _int


class ItemScalarAggregateOutput(TypedDict, total=False):
    """Item output including scalar fields"""
    id: _str
    name: _str
    price: decimal.Decimal
    qrCode: _str
    description: _str
    category: _str
    available: _bool
    stockLevel: _int
    imageUrl: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ItemMinAggregateOutput = ItemScalarAggregateOutput
ItemMaxAggregateOutput = ItemScalarAggregateOutput


class ItemMaxAggregateInput(TypedDict, total=False):
    """Item input for aggregating by max"""
    id: bool
    name: bool
    price: bool
    qrCode: bool
    description: bool
    category: bool
    available: bool
    stockLevel: bool
    imageUrl: bool
    createdAt: bool
    updatedAt: bool


class ItemMinAggregateInput(TypedDict, total=False):
    """Item input for aggregating by min"""
    id: bool
    name: bool
    price: bool
    qrCode: bool
    description: bool
    category: bool
    available: bool
    stockLevel: bool
    imageUrl: bool
    createdAt: bool
    updatedAt: bool


class ItemNumberAggregateInput(TypedDict, total=False):
    """Item input for aggregating numbers"""
    stockLevel: bool


ItemAvgAggregateInput = ItemNumberAggregateInput
ItemSumAggregateInput = ItemNumberAggregateInput


ItemCountAggregateInput = TypedDict(
    'ItemCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'price': bool,
        'qrCode': bool,
        'description': bool,
        'category': bool,
        'available': bool,
        'stockLevel': bool,
        'imageUrl': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ItemCountAggregateOutput = TypedDict(
    'ItemCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'price': int,
        'qrCode': int,
        'description': int,
        'category': int,
        'available': int,
        'stockLevel': int,
        'imageUrl': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ItemKeys = Literal[
    'id',
    'name',
    'price',
    'qrCode',
    'description',
    'category',
    'available',
    'stockLevel',
    'imageUrl',
    'orderItems',
    'createdAt',
    'updatedAt',
]
ItemScalarFieldKeys = Literal[
    'id',
    'name',
    'price',
    'qrCode',
    'description',
    'category',
    'available',
    'stockLevel',
    'imageUrl',
    'createdAt',
    'updatedAt',
]
ItemScalarFieldKeysT = TypeVar('ItemScalarFieldKeysT', bound=ItemScalarFieldKeys)

ItemRelationalFieldKeys = Literal[
        'orderItems',
    ]

# Order types

class OrderOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Order create method"""
    id: _str
    reservationId: _str
    reservation: 'ReservationCreateNestedWithoutRelationsInput'
    orderItems: 'OrderItemCreateManyNestedWithoutRelationsInput'
    status: _str
    paymentId: Optional[_str]
    payment: 'PaymentCreateNestedWithoutRelationsInput'
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderCreateInput(OrderOptionalCreateInput):
    """Required arguments to the Order create method"""
    totalAmount: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OrderOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Order create method, without relations"""
    id: _str
    reservationId: _str
    status: _str
    paymentId: Optional[_str]
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderCreateWithoutRelationsInput(OrderOptionalCreateWithoutRelationsInput):
    """Required arguments to the Order create method, without relations"""
    totalAmount: decimal.Decimal

class OrderConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'OrderCreateWithoutRelationsInput'
    where: 'OrderWhereUniqueInput'

class OrderCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderCreateWithoutRelationsInput'
    connect: 'OrderWhereUniqueInput'
    connect_or_create: 'OrderConnectOrCreateWithoutRelationsInput'


class OrderCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OrderCreateWithoutRelationsInput', List['OrderCreateWithoutRelationsInput']]
    connect: Union['OrderWhereUniqueInput', List['OrderWhereUniqueInput']]
    connect_or_create: Union['OrderConnectOrCreateWithoutRelationsInput', List['OrderConnectOrCreateWithoutRelationsInput']]

_OrderWhereUnique_id_Input = TypedDict(
    '_OrderWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

OrderWhereUniqueInput = _OrderWhereUnique_id_Input


class OrderUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    reservation: 'ReservationUpdateOneWithoutRelationsInput'
    orderItems: 'OrderItemUpdateManyWithoutRelationsInput'
    totalAmount: decimal.Decimal
    status: _str
    payment: 'PaymentUpdateOneWithoutRelationsInput'
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    totalAmount: decimal.Decimal
    status: _str
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OrderCreateWithoutRelationsInput']
    connect: List['OrderWhereUniqueInput']
    connect_or_create: List['OrderConnectOrCreateWithoutRelationsInput']
    set: List['OrderWhereUniqueInput']
    disconnect: List['OrderWhereUniqueInput']
    delete: List['OrderWhereUniqueInput']

    # TODO
    # update: List['OrderUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OrderUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OrderScalarWhereInput']
    # upsert: List['OrderUpserteWithWhereUniqueWithoutRelationsInput']


class OrderUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderCreateWithoutRelationsInput'
    connect: 'OrderWhereUniqueInput'
    connect_or_create: 'OrderConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OrderUpdateInput'
    # upsert: 'OrderUpsertWithoutRelationsInput'


class OrderUpsertInput(TypedDict):
    create: 'OrderCreateInput'
    update: 'OrderUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Order_id_OrderByInput = TypedDict(
    '_Order_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Order_reservationId_OrderByInput = TypedDict(
    '_Order_reservationId_OrderByInput',
    {
        'reservationId': 'SortOrder',
    },
    total=True
)

_Order_totalAmount_OrderByInput = TypedDict(
    '_Order_totalAmount_OrderByInput',
    {
        'totalAmount': 'SortOrder',
    },
    total=True
)

_Order_status_OrderByInput = TypedDict(
    '_Order_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Order_paymentId_OrderByInput = TypedDict(
    '_Order_paymentId_OrderByInput',
    {
        'paymentId': 'SortOrder',
    },
    total=True
)

_Order_notes_OrderByInput = TypedDict(
    '_Order_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_Order_createdAt_OrderByInput = TypedDict(
    '_Order_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Order_updatedAt_OrderByInput = TypedDict(
    '_Order_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Order_RelevanceInner = TypedDict(
    '_Order_RelevanceInner',
    {
        'fields': 'List[OrderScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Order_RelevanceOrderByInput = TypedDict(
    '_Order_RelevanceOrderByInput',
    {
        '_relevance': '_Order_RelevanceInner',
    },
    total=True
)

OrderOrderByInput = Union[
    '_Order_id_OrderByInput',
    '_Order_reservationId_OrderByInput',
    '_Order_totalAmount_OrderByInput',
    '_Order_status_OrderByInput',
    '_Order_paymentId_OrderByInput',
    '_Order_notes_OrderByInput',
    '_Order_createdAt_OrderByInput',
    '_Order_updatedAt_OrderByInput',
    '_Order_RelevanceOrderByInput',
]



# recursive Order types
# TODO: cleanup these types



OrderRelationFilter = TypedDict(
    'OrderRelationFilter',
    {
        'is': 'OrderWhereInput',
        'is_not': 'OrderWhereInput',
    },
    total=False,
)


class OrderListRelationFilter(TypedDict, total=False):
    some: 'OrderWhereInput'
    none: 'OrderWhereInput'
    every: 'OrderWhereInput'


class OrderInclude(TypedDict, total=False):
    """Order relational arguments"""
    reservation: Union[bool, 'ReservationArgsFromOrder']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrder']
    payment: Union[bool, 'PaymentArgsFromOrder']


class AdminIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""


class AdminArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    reservations: Union[bool, 'FindManyReservationArgsFromOrder']


class GuestArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    guest: Union[bool, 'GuestArgsFromOrder']
    orders: Union[bool, 'FindManyOrderArgsFromOrder']
    payments: Union[bool, 'FindManyPaymentArgsFromOrder']


class ReservationArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrder']


class ItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    reservation: Union[bool, 'ReservationArgsFromOrder']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrder']
    payment: Union[bool, 'PaymentArgsFromOrder']


class OrderArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    order: Union[bool, 'OrderArgsFromOrder']
    item: Union[bool, 'ItemArgsFromOrder']


class OrderItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""
    reservation: Union[bool, 'ReservationArgsFromOrder']
    orders: Union[bool, 'FindManyOrderArgsFromOrder']


class PaymentArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""


class NotificationPreferenceArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromOrder(TypedDict, total=False):
    """Relational arguments for Order"""


class NotificationArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromOrder(TypedDict, total=False):
    """Arguments for Order"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyOrderArgs = FindManyOrderArgsFromOrder
FindFirstOrderArgs = FindManyOrderArgsFromOrder


class OrderWhereInput(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    reservationId: Union[_str, 'types.StringFilter']
    reservation: 'ReservationRelationFilter'
    orderItems: 'OrderItemListRelationFilter'
    totalAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    status: Union[_str, 'types.StringFilter']
    paymentId: Union[None, _str, 'types.StringFilter']
    payment: 'PaymentRelationFilter'
    notes: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['OrderWhereInput', List['OrderWhereInput']]
    # but this causes mypy to hang :/
    AND: List['OrderWhereInput']
    OR: List['OrderWhereInput']
    NOT: List['OrderWhereInput']



# aggregate Order types


class OrderScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Order arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    reservationId: Union[_str, 'types.StringWithAggregatesFilter']
    totalAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    paymentId: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderScalarWhereWithAggregatesInput']
    OR: List['OrderScalarWhereWithAggregatesInput']
    NOT: List['OrderScalarWhereWithAggregatesInput']



class OrderGroupByOutput(TypedDict, total=False):
    id: _str
    reservationId: _str
    totalAmount: decimal.Decimal
    status: _str
    paymentId: _str
    notes: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'OrderSumAggregateOutput'
    _avg: 'OrderAvgAggregateOutput'
    _min: 'OrderMinAggregateOutput'
    _max: 'OrderMaxAggregateOutput'
    _count: 'OrderCountAggregateOutput'


class OrderAvgAggregateOutput(TypedDict, total=False):
    """Order output for aggregating averages"""


class OrderSumAggregateOutput(TypedDict, total=False):
    """Order output for aggregating sums"""


class OrderScalarAggregateOutput(TypedDict, total=False):
    """Order output including scalar fields"""
    id: _str
    reservationId: _str
    totalAmount: decimal.Decimal
    status: _str
    paymentId: _str
    notes: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


OrderMinAggregateOutput = OrderScalarAggregateOutput
OrderMaxAggregateOutput = OrderScalarAggregateOutput


class OrderMaxAggregateInput(TypedDict, total=False):
    """Order input for aggregating by max"""
    id: bool
    reservationId: bool
    totalAmount: bool
    status: bool
    paymentId: bool
    notes: bool
    createdAt: bool
    updatedAt: bool


class OrderMinAggregateInput(TypedDict, total=False):
    """Order input for aggregating by min"""
    id: bool
    reservationId: bool
    totalAmount: bool
    status: bool
    paymentId: bool
    notes: bool
    createdAt: bool
    updatedAt: bool


class OrderNumberAggregateInput(TypedDict, total=False):
    """Order input for aggregating numbers"""


OrderAvgAggregateInput = OrderNumberAggregateInput
OrderSumAggregateInput = OrderNumberAggregateInput


OrderCountAggregateInput = TypedDict(
    'OrderCountAggregateInput',
    {
        'id': bool,
        'reservationId': bool,
        'totalAmount': bool,
        'status': bool,
        'paymentId': bool,
        'notes': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

OrderCountAggregateOutput = TypedDict(
    'OrderCountAggregateOutput',
    {
        'id': int,
        'reservationId': int,
        'totalAmount': int,
        'status': int,
        'paymentId': int,
        'notes': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


OrderKeys = Literal[
    'id',
    'reservationId',
    'reservation',
    'orderItems',
    'totalAmount',
    'status',
    'paymentId',
    'payment',
    'notes',
    'createdAt',
    'updatedAt',
]
OrderScalarFieldKeys = Literal[
    'id',
    'reservationId',
    'totalAmount',
    'status',
    'paymentId',
    'notes',
    'createdAt',
    'updatedAt',
]
OrderScalarFieldKeysT = TypeVar('OrderScalarFieldKeysT', bound=OrderScalarFieldKeys)

OrderRelationalFieldKeys = Literal[
        'reservation',
        'orderItems',
        'payment',
    ]

# OrderItem types

class OrderItemOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the OrderItem create method"""
    id: _str
    orderId: _str
    order: 'OrderCreateNestedWithoutRelationsInput'
    itemId: _str
    item: 'ItemCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderItemCreateInput(OrderItemOptionalCreateInput):
    """Required arguments to the OrderItem create method"""
    quantity: _int
    price: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OrderItemOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the OrderItem create method, without relations"""
    id: _str
    orderId: _str
    itemId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderItemCreateWithoutRelationsInput(OrderItemOptionalCreateWithoutRelationsInput):
    """Required arguments to the OrderItem create method, without relations"""
    quantity: _int
    price: decimal.Decimal

class OrderItemConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'OrderItemCreateWithoutRelationsInput'
    where: 'OrderItemWhereUniqueInput'

class OrderItemCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderItemCreateWithoutRelationsInput'
    connect: 'OrderItemWhereUniqueInput'
    connect_or_create: 'OrderItemConnectOrCreateWithoutRelationsInput'


class OrderItemCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OrderItemCreateWithoutRelationsInput', List['OrderItemCreateWithoutRelationsInput']]
    connect: Union['OrderItemWhereUniqueInput', List['OrderItemWhereUniqueInput']]
    connect_or_create: Union['OrderItemConnectOrCreateWithoutRelationsInput', List['OrderItemConnectOrCreateWithoutRelationsInput']]

_OrderItemWhereUnique_id_Input = TypedDict(
    '_OrderItemWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

OrderItemWhereUniqueInput = _OrderItemWhereUnique_id_Input


class OrderItemUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    order: 'OrderUpdateOneWithoutRelationsInput'
    item: 'ItemUpdateOneWithoutRelationsInput'
    quantity: Union[AtomicIntInput, _int]
    price: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderItemUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    quantity: Union[AtomicIntInput, _int]
    price: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class OrderItemUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OrderItemCreateWithoutRelationsInput']
    connect: List['OrderItemWhereUniqueInput']
    connect_or_create: List['OrderItemConnectOrCreateWithoutRelationsInput']
    set: List['OrderItemWhereUniqueInput']
    disconnect: List['OrderItemWhereUniqueInput']
    delete: List['OrderItemWhereUniqueInput']

    # TODO
    # update: List['OrderItemUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OrderItemUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OrderItemScalarWhereInput']
    # upsert: List['OrderItemUpserteWithWhereUniqueWithoutRelationsInput']


class OrderItemUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OrderItemCreateWithoutRelationsInput'
    connect: 'OrderItemWhereUniqueInput'
    connect_or_create: 'OrderItemConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OrderItemUpdateInput'
    # upsert: 'OrderItemUpsertWithoutRelationsInput'


class OrderItemUpsertInput(TypedDict):
    create: 'OrderItemCreateInput'
    update: 'OrderItemUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_OrderItem_id_OrderByInput = TypedDict(
    '_OrderItem_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_OrderItem_orderId_OrderByInput = TypedDict(
    '_OrderItem_orderId_OrderByInput',
    {
        'orderId': 'SortOrder',
    },
    total=True
)

_OrderItem_itemId_OrderByInput = TypedDict(
    '_OrderItem_itemId_OrderByInput',
    {
        'itemId': 'SortOrder',
    },
    total=True
)

_OrderItem_quantity_OrderByInput = TypedDict(
    '_OrderItem_quantity_OrderByInput',
    {
        'quantity': 'SortOrder',
    },
    total=True
)

_OrderItem_price_OrderByInput = TypedDict(
    '_OrderItem_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_OrderItem_createdAt_OrderByInput = TypedDict(
    '_OrderItem_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_OrderItem_updatedAt_OrderByInput = TypedDict(
    '_OrderItem_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_OrderItem_RelevanceInner = TypedDict(
    '_OrderItem_RelevanceInner',
    {
        'fields': 'List[OrderItemScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_OrderItem_RelevanceOrderByInput = TypedDict(
    '_OrderItem_RelevanceOrderByInput',
    {
        '_relevance': '_OrderItem_RelevanceInner',
    },
    total=True
)

OrderItemOrderByInput = Union[
    '_OrderItem_id_OrderByInput',
    '_OrderItem_orderId_OrderByInput',
    '_OrderItem_itemId_OrderByInput',
    '_OrderItem_quantity_OrderByInput',
    '_OrderItem_price_OrderByInput',
    '_OrderItem_createdAt_OrderByInput',
    '_OrderItem_updatedAt_OrderByInput',
    '_OrderItem_RelevanceOrderByInput',
]



# recursive OrderItem types
# TODO: cleanup these types



OrderItemRelationFilter = TypedDict(
    'OrderItemRelationFilter',
    {
        'is': 'OrderItemWhereInput',
        'is_not': 'OrderItemWhereInput',
    },
    total=False,
)


class OrderItemListRelationFilter(TypedDict, total=False):
    some: 'OrderItemWhereInput'
    none: 'OrderItemWhereInput'
    every: 'OrderItemWhereInput'


class OrderItemInclude(TypedDict, total=False):
    """OrderItem relational arguments"""
    order: Union[bool, 'OrderArgsFromOrderItem']
    item: Union[bool, 'ItemArgsFromOrderItem']


class AdminIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""


class AdminArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    reservations: Union[bool, 'FindManyReservationArgsFromOrderItem']


class GuestArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    guest: Union[bool, 'GuestArgsFromOrderItem']
    orders: Union[bool, 'FindManyOrderArgsFromOrderItem']
    payments: Union[bool, 'FindManyPaymentArgsFromOrderItem']


class ReservationArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItem']


class ItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    reservation: Union[bool, 'ReservationArgsFromOrderItem']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromOrderItem']
    payment: Union[bool, 'PaymentArgsFromOrderItem']


class OrderArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    order: Union[bool, 'OrderArgsFromOrderItem']
    item: Union[bool, 'ItemArgsFromOrderItem']


class OrderItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""
    reservation: Union[bool, 'ReservationArgsFromOrderItem']
    orders: Union[bool, 'FindManyOrderArgsFromOrderItem']


class PaymentArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""


class NotificationPreferenceArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromOrderItem(TypedDict, total=False):
    """Relational arguments for OrderItem"""


class NotificationArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromOrderItem(TypedDict, total=False):
    """Arguments for OrderItem"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyOrderItemArgs = FindManyOrderItemArgsFromOrderItem
FindFirstOrderItemArgs = FindManyOrderItemArgsFromOrderItem


class OrderItemWhereInput(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    orderId: Union[_str, 'types.StringFilter']
    order: 'OrderRelationFilter'
    itemId: Union[_str, 'types.StringFilter']
    item: 'ItemRelationFilter'
    quantity: Union[_int, 'types.IntFilter']
    price: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['OrderItemWhereInput', List['OrderItemWhereInput']]
    # but this causes mypy to hang :/
    AND: List['OrderItemWhereInput']
    OR: List['OrderItemWhereInput']
    NOT: List['OrderItemWhereInput']



# aggregate OrderItem types


class OrderItemScalarWhereWithAggregatesInput(TypedDict, total=False):
    """OrderItem arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    orderId: Union[_str, 'types.StringWithAggregatesFilter']
    itemId: Union[_str, 'types.StringWithAggregatesFilter']
    quantity: Union[_int, 'types.IntWithAggregatesFilter']
    price: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['OrderItemScalarWhereWithAggregatesInput']
    OR: List['OrderItemScalarWhereWithAggregatesInput']
    NOT: List['OrderItemScalarWhereWithAggregatesInput']



class OrderItemGroupByOutput(TypedDict, total=False):
    id: _str
    orderId: _str
    itemId: _str
    quantity: _int
    price: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'OrderItemSumAggregateOutput'
    _avg: 'OrderItemAvgAggregateOutput'
    _min: 'OrderItemMinAggregateOutput'
    _max: 'OrderItemMaxAggregateOutput'
    _count: 'OrderItemCountAggregateOutput'


class OrderItemAvgAggregateOutput(TypedDict, total=False):
    """OrderItem output for aggregating averages"""
    quantity: float


class OrderItemSumAggregateOutput(TypedDict, total=False):
    """OrderItem output for aggregating sums"""
    quantity: _int


class OrderItemScalarAggregateOutput(TypedDict, total=False):
    """OrderItem output including scalar fields"""
    id: _str
    orderId: _str
    itemId: _str
    quantity: _int
    price: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


OrderItemMinAggregateOutput = OrderItemScalarAggregateOutput
OrderItemMaxAggregateOutput = OrderItemScalarAggregateOutput


class OrderItemMaxAggregateInput(TypedDict, total=False):
    """OrderItem input for aggregating by max"""
    id: bool
    orderId: bool
    itemId: bool
    quantity: bool
    price: bool
    createdAt: bool
    updatedAt: bool


class OrderItemMinAggregateInput(TypedDict, total=False):
    """OrderItem input for aggregating by min"""
    id: bool
    orderId: bool
    itemId: bool
    quantity: bool
    price: bool
    createdAt: bool
    updatedAt: bool


class OrderItemNumberAggregateInput(TypedDict, total=False):
    """OrderItem input for aggregating numbers"""
    quantity: bool


OrderItemAvgAggregateInput = OrderItemNumberAggregateInput
OrderItemSumAggregateInput = OrderItemNumberAggregateInput


OrderItemCountAggregateInput = TypedDict(
    'OrderItemCountAggregateInput',
    {
        'id': bool,
        'orderId': bool,
        'itemId': bool,
        'quantity': bool,
        'price': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

OrderItemCountAggregateOutput = TypedDict(
    'OrderItemCountAggregateOutput',
    {
        'id': int,
        'orderId': int,
        'itemId': int,
        'quantity': int,
        'price': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


OrderItemKeys = Literal[
    'id',
    'orderId',
    'order',
    'itemId',
    'item',
    'quantity',
    'price',
    'createdAt',
    'updatedAt',
]
OrderItemScalarFieldKeys = Literal[
    'id',
    'orderId',
    'itemId',
    'quantity',
    'price',
    'createdAt',
    'updatedAt',
]
OrderItemScalarFieldKeysT = TypeVar('OrderItemScalarFieldKeysT', bound=OrderItemScalarFieldKeys)

OrderItemRelationalFieldKeys = Literal[
        'order',
        'item',
    ]

# Payment types

class PaymentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Payment create method"""
    id: _str
    reservationId: _str
    reservation: 'ReservationCreateNestedWithoutRelationsInput'
    orders: 'OrderCreateManyNestedWithoutRelationsInput'
    status: _str
    transactionId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentCreateInput(PaymentOptionalCreateInput):
    """Required arguments to the Payment create method"""
    amount: decimal.Decimal
    method: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PaymentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Payment create method, without relations"""
    id: _str
    reservationId: _str
    status: _str
    transactionId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentCreateWithoutRelationsInput(PaymentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Payment create method, without relations"""
    amount: decimal.Decimal
    method: _str

class PaymentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PaymentCreateWithoutRelationsInput'
    where: 'PaymentWhereUniqueInput'

class PaymentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentCreateWithoutRelationsInput'
    connect: 'PaymentWhereUniqueInput'
    connect_or_create: 'PaymentConnectOrCreateWithoutRelationsInput'


class PaymentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PaymentCreateWithoutRelationsInput', List['PaymentCreateWithoutRelationsInput']]
    connect: Union['PaymentWhereUniqueInput', List['PaymentWhereUniqueInput']]
    connect_or_create: Union['PaymentConnectOrCreateWithoutRelationsInput', List['PaymentConnectOrCreateWithoutRelationsInput']]

_PaymentWhereUnique_id_Input = TypedDict(
    '_PaymentWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_PaymentWhereUnique_transactionId_Input = TypedDict(
    '_PaymentWhereUnique_transactionId_Input',
    {
        'transactionId': '_str',
    },
    total=True
)

PaymentWhereUniqueInput = Union[
    '_PaymentWhereUnique_id_Input',
    '_PaymentWhereUnique_transactionId_Input',
]


class PaymentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    reservation: 'ReservationUpdateOneWithoutRelationsInput'
    orders: 'OrderUpdateManyWithoutRelationsInput'
    amount: decimal.Decimal
    status: _str
    method: _str
    transactionId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    amount: decimal.Decimal
    status: _str
    method: _str
    transactionId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PaymentCreateWithoutRelationsInput']
    connect: List['PaymentWhereUniqueInput']
    connect_or_create: List['PaymentConnectOrCreateWithoutRelationsInput']
    set: List['PaymentWhereUniqueInput']
    disconnect: List['PaymentWhereUniqueInput']
    delete: List['PaymentWhereUniqueInput']

    # TODO
    # update: List['PaymentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PaymentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PaymentScalarWhereInput']
    # upsert: List['PaymentUpserteWithWhereUniqueWithoutRelationsInput']


class PaymentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentCreateWithoutRelationsInput'
    connect: 'PaymentWhereUniqueInput'
    connect_or_create: 'PaymentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PaymentUpdateInput'
    # upsert: 'PaymentUpsertWithoutRelationsInput'


class PaymentUpsertInput(TypedDict):
    create: 'PaymentCreateInput'
    update: 'PaymentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Payment_id_OrderByInput = TypedDict(
    '_Payment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Payment_reservationId_OrderByInput = TypedDict(
    '_Payment_reservationId_OrderByInput',
    {
        'reservationId': 'SortOrder',
    },
    total=True
)

_Payment_amount_OrderByInput = TypedDict(
    '_Payment_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Payment_status_OrderByInput = TypedDict(
    '_Payment_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Payment_method_OrderByInput = TypedDict(
    '_Payment_method_OrderByInput',
    {
        'method': 'SortOrder',
    },
    total=True
)

_Payment_transactionId_OrderByInput = TypedDict(
    '_Payment_transactionId_OrderByInput',
    {
        'transactionId': 'SortOrder',
    },
    total=True
)

_Payment_createdAt_OrderByInput = TypedDict(
    '_Payment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Payment_updatedAt_OrderByInput = TypedDict(
    '_Payment_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Payment_RelevanceInner = TypedDict(
    '_Payment_RelevanceInner',
    {
        'fields': 'List[PaymentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Payment_RelevanceOrderByInput = TypedDict(
    '_Payment_RelevanceOrderByInput',
    {
        '_relevance': '_Payment_RelevanceInner',
    },
    total=True
)

PaymentOrderByInput = Union[
    '_Payment_id_OrderByInput',
    '_Payment_reservationId_OrderByInput',
    '_Payment_amount_OrderByInput',
    '_Payment_status_OrderByInput',
    '_Payment_method_OrderByInput',
    '_Payment_transactionId_OrderByInput',
    '_Payment_createdAt_OrderByInput',
    '_Payment_updatedAt_OrderByInput',
    '_Payment_RelevanceOrderByInput',
]



# recursive Payment types
# TODO: cleanup these types



PaymentRelationFilter = TypedDict(
    'PaymentRelationFilter',
    {
        'is': 'PaymentWhereInput',
        'is_not': 'PaymentWhereInput',
    },
    total=False,
)


class PaymentListRelationFilter(TypedDict, total=False):
    some: 'PaymentWhereInput'
    none: 'PaymentWhereInput'
    every: 'PaymentWhereInput'


class PaymentInclude(TypedDict, total=False):
    """Payment relational arguments"""
    reservation: Union[bool, 'ReservationArgsFromPayment']
    orders: Union[bool, 'FindManyOrderArgsFromPayment']


class AdminIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""


class AdminArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    reservations: Union[bool, 'FindManyReservationArgsFromPayment']


class GuestArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    guest: Union[bool, 'GuestArgsFromPayment']
    orders: Union[bool, 'FindManyOrderArgsFromPayment']
    payments: Union[bool, 'FindManyPaymentArgsFromPayment']


class ReservationArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPayment']


class ItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    reservation: Union[bool, 'ReservationArgsFromPayment']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromPayment']
    payment: Union[bool, 'PaymentArgsFromPayment']


class OrderArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    order: Union[bool, 'OrderArgsFromPayment']
    item: Union[bool, 'ItemArgsFromPayment']


class OrderItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""
    reservation: Union[bool, 'ReservationArgsFromPayment']
    orders: Union[bool, 'FindManyOrderArgsFromPayment']


class PaymentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""


class NotificationPreferenceArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromPayment(TypedDict, total=False):
    """Relational arguments for Payment"""


class NotificationArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromPayment(TypedDict, total=False):
    """Arguments for Payment"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyPaymentArgs = FindManyPaymentArgsFromPayment
FindFirstPaymentArgs = FindManyPaymentArgsFromPayment


class PaymentWhereInput(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    reservationId: Union[_str, 'types.StringFilter']
    reservation: 'ReservationRelationFilter'
    orders: 'OrderListRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    status: Union[_str, 'types.StringFilter']
    method: Union[_str, 'types.StringFilter']
    transactionId: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PaymentWhereInput', List['PaymentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PaymentWhereInput']
    OR: List['PaymentWhereInput']
    NOT: List['PaymentWhereInput']



# aggregate Payment types


class PaymentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Payment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    reservationId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    method: Union[_str, 'types.StringWithAggregatesFilter']
    transactionId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PaymentScalarWhereWithAggregatesInput']
    OR: List['PaymentScalarWhereWithAggregatesInput']
    NOT: List['PaymentScalarWhereWithAggregatesInput']



class PaymentGroupByOutput(TypedDict, total=False):
    id: _str
    reservationId: _str
    amount: decimal.Decimal
    status: _str
    method: _str
    transactionId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PaymentSumAggregateOutput'
    _avg: 'PaymentAvgAggregateOutput'
    _min: 'PaymentMinAggregateOutput'
    _max: 'PaymentMaxAggregateOutput'
    _count: 'PaymentCountAggregateOutput'


class PaymentAvgAggregateOutput(TypedDict, total=False):
    """Payment output for aggregating averages"""


class PaymentSumAggregateOutput(TypedDict, total=False):
    """Payment output for aggregating sums"""


class PaymentScalarAggregateOutput(TypedDict, total=False):
    """Payment output including scalar fields"""
    id: _str
    reservationId: _str
    amount: decimal.Decimal
    status: _str
    method: _str
    transactionId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PaymentMinAggregateOutput = PaymentScalarAggregateOutput
PaymentMaxAggregateOutput = PaymentScalarAggregateOutput


class PaymentMaxAggregateInput(TypedDict, total=False):
    """Payment input for aggregating by max"""
    id: bool
    reservationId: bool
    amount: bool
    status: bool
    method: bool
    transactionId: bool
    createdAt: bool
    updatedAt: bool


class PaymentMinAggregateInput(TypedDict, total=False):
    """Payment input for aggregating by min"""
    id: bool
    reservationId: bool
    amount: bool
    status: bool
    method: bool
    transactionId: bool
    createdAt: bool
    updatedAt: bool


class PaymentNumberAggregateInput(TypedDict, total=False):
    """Payment input for aggregating numbers"""


PaymentAvgAggregateInput = PaymentNumberAggregateInput
PaymentSumAggregateInput = PaymentNumberAggregateInput


PaymentCountAggregateInput = TypedDict(
    'PaymentCountAggregateInput',
    {
        'id': bool,
        'reservationId': bool,
        'amount': bool,
        'status': bool,
        'method': bool,
        'transactionId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PaymentCountAggregateOutput = TypedDict(
    'PaymentCountAggregateOutput',
    {
        'id': int,
        'reservationId': int,
        'amount': int,
        'status': int,
        'method': int,
        'transactionId': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PaymentKeys = Literal[
    'id',
    'reservationId',
    'reservation',
    'orders',
    'amount',
    'status',
    'method',
    'transactionId',
    'createdAt',
    'updatedAt',
]
PaymentScalarFieldKeys = Literal[
    'id',
    'reservationId',
    'amount',
    'status',
    'method',
    'transactionId',
    'createdAt',
    'updatedAt',
]
PaymentScalarFieldKeysT = TypeVar('PaymentScalarFieldKeysT', bound=PaymentScalarFieldKeys)

PaymentRelationalFieldKeys = Literal[
        'reservation',
        'orders',
    ]

# NotificationPreference types

class NotificationPreferenceOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the NotificationPreference create method"""
    id: _str
    quietHours: Optional['fields.Json']
    enabled: _bool
    mutedUntil: Optional[datetime.datetime]
    priorityThreshold: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationPreferenceCreateInput(NotificationPreferenceOptionalCreateInput):
    """Required arguments to the NotificationPreference create method"""
    userId: _str
    channels: 'fields.Json'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NotificationPreferenceOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the NotificationPreference create method, without relations"""
    id: _str
    quietHours: Optional['fields.Json']
    enabled: _bool
    mutedUntil: Optional[datetime.datetime]
    priorityThreshold: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationPreferenceCreateWithoutRelationsInput(NotificationPreferenceOptionalCreateWithoutRelationsInput):
    """Required arguments to the NotificationPreference create method, without relations"""
    userId: _str
    channels: 'fields.Json'

class NotificationPreferenceConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'NotificationPreferenceCreateWithoutRelationsInput'
    where: 'NotificationPreferenceWhereUniqueInput'

class NotificationPreferenceCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationPreferenceCreateWithoutRelationsInput'
    connect: 'NotificationPreferenceWhereUniqueInput'
    connect_or_create: 'NotificationPreferenceConnectOrCreateWithoutRelationsInput'


class NotificationPreferenceCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NotificationPreferenceCreateWithoutRelationsInput', List['NotificationPreferenceCreateWithoutRelationsInput']]
    connect: Union['NotificationPreferenceWhereUniqueInput', List['NotificationPreferenceWhereUniqueInput']]
    connect_or_create: Union['NotificationPreferenceConnectOrCreateWithoutRelationsInput', List['NotificationPreferenceConnectOrCreateWithoutRelationsInput']]

_NotificationPreferenceWhereUnique_id_Input = TypedDict(
    '_NotificationPreferenceWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_NotificationPreferenceWhereUnique_userId_Input = TypedDict(
    '_NotificationPreferenceWhereUnique_userId_Input',
    {
        'userId': '_str',
    },
    total=True
)

NotificationPreferenceWhereUniqueInput = Union[
    '_NotificationPreferenceWhereUnique_id_Input',
    '_NotificationPreferenceWhereUnique_userId_Input',
]


class NotificationPreferenceUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    userId: _str
    channels: 'fields.Json'
    quietHours: Optional['fields.Json']
    enabled: _bool
    mutedUntil: Optional[datetime.datetime]
    priorityThreshold: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationPreferenceUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    userId: _str
    channels: 'fields.Json'
    quietHours: Optional['fields.Json']
    enabled: _bool
    mutedUntil: Optional[datetime.datetime]
    priorityThreshold: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationPreferenceUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NotificationPreferenceCreateWithoutRelationsInput']
    connect: List['NotificationPreferenceWhereUniqueInput']
    connect_or_create: List['NotificationPreferenceConnectOrCreateWithoutRelationsInput']
    set: List['NotificationPreferenceWhereUniqueInput']
    disconnect: List['NotificationPreferenceWhereUniqueInput']
    delete: List['NotificationPreferenceWhereUniqueInput']

    # TODO
    # update: List['NotificationPreferenceUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NotificationPreferenceUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NotificationPreferenceScalarWhereInput']
    # upsert: List['NotificationPreferenceUpserteWithWhereUniqueWithoutRelationsInput']


class NotificationPreferenceUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationPreferenceCreateWithoutRelationsInput'
    connect: 'NotificationPreferenceWhereUniqueInput'
    connect_or_create: 'NotificationPreferenceConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NotificationPreferenceUpdateInput'
    # upsert: 'NotificationPreferenceUpsertWithoutRelationsInput'


class NotificationPreferenceUpsertInput(TypedDict):
    create: 'NotificationPreferenceCreateInput'
    update: 'NotificationPreferenceUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_NotificationPreference_id_OrderByInput = TypedDict(
    '_NotificationPreference_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_NotificationPreference_userId_OrderByInput = TypedDict(
    '_NotificationPreference_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_NotificationPreference_channels_OrderByInput = TypedDict(
    '_NotificationPreference_channels_OrderByInput',
    {
        'channels': 'SortOrder',
    },
    total=True
)

_NotificationPreference_quietHours_OrderByInput = TypedDict(
    '_NotificationPreference_quietHours_OrderByInput',
    {
        'quietHours': 'SortOrder',
    },
    total=True
)

_NotificationPreference_enabled_OrderByInput = TypedDict(
    '_NotificationPreference_enabled_OrderByInput',
    {
        'enabled': 'SortOrder',
    },
    total=True
)

_NotificationPreference_mutedUntil_OrderByInput = TypedDict(
    '_NotificationPreference_mutedUntil_OrderByInput',
    {
        'mutedUntil': 'SortOrder',
    },
    total=True
)

_NotificationPreference_priorityThreshold_OrderByInput = TypedDict(
    '_NotificationPreference_priorityThreshold_OrderByInput',
    {
        'priorityThreshold': 'SortOrder',
    },
    total=True
)

_NotificationPreference_createdAt_OrderByInput = TypedDict(
    '_NotificationPreference_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_NotificationPreference_updatedAt_OrderByInput = TypedDict(
    '_NotificationPreference_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_NotificationPreference_RelevanceInner = TypedDict(
    '_NotificationPreference_RelevanceInner',
    {
        'fields': 'List[NotificationPreferenceScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_NotificationPreference_RelevanceOrderByInput = TypedDict(
    '_NotificationPreference_RelevanceOrderByInput',
    {
        '_relevance': '_NotificationPreference_RelevanceInner',
    },
    total=True
)

NotificationPreferenceOrderByInput = Union[
    '_NotificationPreference_id_OrderByInput',
    '_NotificationPreference_userId_OrderByInput',
    '_NotificationPreference_channels_OrderByInput',
    '_NotificationPreference_quietHours_OrderByInput',
    '_NotificationPreference_enabled_OrderByInput',
    '_NotificationPreference_mutedUntil_OrderByInput',
    '_NotificationPreference_priorityThreshold_OrderByInput',
    '_NotificationPreference_createdAt_OrderByInput',
    '_NotificationPreference_updatedAt_OrderByInput',
    '_NotificationPreference_RelevanceOrderByInput',
]



# recursive NotificationPreference types
# TODO: cleanup these types



NotificationPreferenceRelationFilter = TypedDict(
    'NotificationPreferenceRelationFilter',
    {
        'is': 'NotificationPreferenceWhereInput',
        'is_not': 'NotificationPreferenceWhereInput',
    },
    total=False,
)


class NotificationPreferenceListRelationFilter(TypedDict, total=False):
    some: 'NotificationPreferenceWhereInput'
    none: 'NotificationPreferenceWhereInput'
    every: 'NotificationPreferenceWhereInput'


class NotificationPreferenceInclude(TypedDict, total=False):
    """NotificationPreference relational arguments"""


class AdminIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""


class AdminArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""
    reservations: Union[bool, 'FindManyReservationArgsFromNotificationPreference']


class GuestArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""
    guest: Union[bool, 'GuestArgsFromNotificationPreference']
    orders: Union[bool, 'FindManyOrderArgsFromNotificationPreference']
    payments: Union[bool, 'FindManyPaymentArgsFromNotificationPreference']


class ReservationArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromNotificationPreference']


class ItemArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""
    reservation: Union[bool, 'ReservationArgsFromNotificationPreference']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromNotificationPreference']
    payment: Union[bool, 'PaymentArgsFromNotificationPreference']


class OrderArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""
    order: Union[bool, 'OrderArgsFromNotificationPreference']
    item: Union[bool, 'ItemArgsFromNotificationPreference']


class OrderItemArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""
    reservation: Union[bool, 'ReservationArgsFromNotificationPreference']
    orders: Union[bool, 'FindManyOrderArgsFromNotificationPreference']


class PaymentArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""


class NotificationPreferenceArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromNotificationPreference(TypedDict, total=False):
    """Relational arguments for NotificationPreference"""


class NotificationArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromNotificationPreference(TypedDict, total=False):
    """Arguments for NotificationPreference"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyNotificationPreferenceArgs = FindManyNotificationPreferenceArgsFromNotificationPreference
FindFirstNotificationPreferenceArgs = FindManyNotificationPreferenceArgsFromNotificationPreference


class NotificationPreferenceWhereInput(TypedDict, total=False):
    """NotificationPreference arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    channels: Union['fields.Json', 'types.JsonFilter']
    quietHours: Union[None, 'fields.Json', 'types.JsonFilter']
    enabled: Union[_bool, 'types.BooleanFilter']
    mutedUntil: Union[None, datetime.datetime, 'types.DateTimeFilter']
    priorityThreshold: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['NotificationPreferenceWhereInput', List['NotificationPreferenceWhereInput']]
    # but this causes mypy to hang :/
    AND: List['NotificationPreferenceWhereInput']
    OR: List['NotificationPreferenceWhereInput']
    NOT: List['NotificationPreferenceWhereInput']



# aggregate NotificationPreference types


class NotificationPreferenceScalarWhereWithAggregatesInput(TypedDict, total=False):
    """NotificationPreference arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    channels: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    quietHours: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    mutedUntil: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    priorityThreshold: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['NotificationPreferenceScalarWhereWithAggregatesInput']
    OR: List['NotificationPreferenceScalarWhereWithAggregatesInput']
    NOT: List['NotificationPreferenceScalarWhereWithAggregatesInput']



class NotificationPreferenceGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    channels: 'fields.Json'
    quietHours: 'fields.Json'
    enabled: _bool
    mutedUntil: datetime.datetime
    priorityThreshold: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'NotificationPreferenceSumAggregateOutput'
    _avg: 'NotificationPreferenceAvgAggregateOutput'
    _min: 'NotificationPreferenceMinAggregateOutput'
    _max: 'NotificationPreferenceMaxAggregateOutput'
    _count: 'NotificationPreferenceCountAggregateOutput'


class NotificationPreferenceAvgAggregateOutput(TypedDict, total=False):
    """NotificationPreference output for aggregating averages"""
    priorityThreshold: float


class NotificationPreferenceSumAggregateOutput(TypedDict, total=False):
    """NotificationPreference output for aggregating sums"""
    priorityThreshold: _int


class NotificationPreferenceScalarAggregateOutput(TypedDict, total=False):
    """NotificationPreference output including scalar fields"""
    id: _str
    userId: _str
    channels: 'fields.Json'
    quietHours: 'fields.Json'
    enabled: _bool
    mutedUntil: datetime.datetime
    priorityThreshold: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


NotificationPreferenceMinAggregateOutput = NotificationPreferenceScalarAggregateOutput
NotificationPreferenceMaxAggregateOutput = NotificationPreferenceScalarAggregateOutput


class NotificationPreferenceMaxAggregateInput(TypedDict, total=False):
    """NotificationPreference input for aggregating by max"""
    id: bool
    userId: bool
    channels: bool
    quietHours: bool
    enabled: bool
    mutedUntil: bool
    priorityThreshold: bool
    createdAt: bool
    updatedAt: bool


class NotificationPreferenceMinAggregateInput(TypedDict, total=False):
    """NotificationPreference input for aggregating by min"""
    id: bool
    userId: bool
    channels: bool
    quietHours: bool
    enabled: bool
    mutedUntil: bool
    priorityThreshold: bool
    createdAt: bool
    updatedAt: bool


class NotificationPreferenceNumberAggregateInput(TypedDict, total=False):
    """NotificationPreference input for aggregating numbers"""
    priorityThreshold: bool


NotificationPreferenceAvgAggregateInput = NotificationPreferenceNumberAggregateInput
NotificationPreferenceSumAggregateInput = NotificationPreferenceNumberAggregateInput


NotificationPreferenceCountAggregateInput = TypedDict(
    'NotificationPreferenceCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'channels': bool,
        'quietHours': bool,
        'enabled': bool,
        'mutedUntil': bool,
        'priorityThreshold': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

NotificationPreferenceCountAggregateOutput = TypedDict(
    'NotificationPreferenceCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'channels': int,
        'quietHours': int,
        'enabled': int,
        'mutedUntil': int,
        'priorityThreshold': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


NotificationPreferenceKeys = Literal[
    'id',
    'userId',
    'channels',
    'quietHours',
    'enabled',
    'mutedUntil',
    'priorityThreshold',
    'createdAt',
    'updatedAt',
]
NotificationPreferenceScalarFieldKeys = Literal[
    'id',
    'userId',
    'channels',
    'quietHours',
    'enabled',
    'mutedUntil',
    'priorityThreshold',
    'createdAt',
    'updatedAt',
]
NotificationPreferenceScalarFieldKeysT = TypeVar('NotificationPreferenceScalarFieldKeysT', bound=NotificationPreferenceScalarFieldKeys)

NotificationPreferenceRelationalFieldKeys = _NoneType

# Notification types

class NotificationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Notification create method"""
    id: _str
    targetUser: Optional[_str]
    metadata: Optional['fields.Json']
    read: _bool
    readAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationCreateInput(NotificationOptionalCreateInput):
    """Required arguments to the Notification create method"""
    type: 'enums.NotificationType'
    message: _str
    priority: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NotificationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Notification create method, without relations"""
    id: _str
    targetUser: Optional[_str]
    metadata: Optional['fields.Json']
    read: _bool
    readAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationCreateWithoutRelationsInput(NotificationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Notification create method, without relations"""
    type: 'enums.NotificationType'
    message: _str
    priority: _str

class NotificationConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'NotificationCreateWithoutRelationsInput'
    where: 'NotificationWhereUniqueInput'

class NotificationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationCreateWithoutRelationsInput'
    connect: 'NotificationWhereUniqueInput'
    connect_or_create: 'NotificationConnectOrCreateWithoutRelationsInput'


class NotificationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NotificationCreateWithoutRelationsInput', List['NotificationCreateWithoutRelationsInput']]
    connect: Union['NotificationWhereUniqueInput', List['NotificationWhereUniqueInput']]
    connect_or_create: Union['NotificationConnectOrCreateWithoutRelationsInput', List['NotificationConnectOrCreateWithoutRelationsInput']]

_NotificationWhereUnique_id_Input = TypedDict(
    '_NotificationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

NotificationWhereUniqueInput = _NotificationWhereUnique_id_Input


class NotificationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    type: 'enums.NotificationType'
    message: _str
    priority: _str
    targetUser: Optional[_str]
    metadata: Optional['fields.Json']
    read: _bool
    readAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    type: 'enums.NotificationType'
    message: _str
    priority: _str
    targetUser: Optional[_str]
    metadata: Optional['fields.Json']
    read: _bool
    readAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class NotificationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NotificationCreateWithoutRelationsInput']
    connect: List['NotificationWhereUniqueInput']
    connect_or_create: List['NotificationConnectOrCreateWithoutRelationsInput']
    set: List['NotificationWhereUniqueInput']
    disconnect: List['NotificationWhereUniqueInput']
    delete: List['NotificationWhereUniqueInput']

    # TODO
    # update: List['NotificationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NotificationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NotificationScalarWhereInput']
    # upsert: List['NotificationUpserteWithWhereUniqueWithoutRelationsInput']


class NotificationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NotificationCreateWithoutRelationsInput'
    connect: 'NotificationWhereUniqueInput'
    connect_or_create: 'NotificationConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NotificationUpdateInput'
    # upsert: 'NotificationUpsertWithoutRelationsInput'


class NotificationUpsertInput(TypedDict):
    create: 'NotificationCreateInput'
    update: 'NotificationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Notification_id_OrderByInput = TypedDict(
    '_Notification_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Notification_type_OrderByInput = TypedDict(
    '_Notification_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Notification_message_OrderByInput = TypedDict(
    '_Notification_message_OrderByInput',
    {
        'message': 'SortOrder',
    },
    total=True
)

_Notification_priority_OrderByInput = TypedDict(
    '_Notification_priority_OrderByInput',
    {
        'priority': 'SortOrder',
    },
    total=True
)

_Notification_targetUser_OrderByInput = TypedDict(
    '_Notification_targetUser_OrderByInput',
    {
        'targetUser': 'SortOrder',
    },
    total=True
)

_Notification_metadata_OrderByInput = TypedDict(
    '_Notification_metadata_OrderByInput',
    {
        'metadata': 'SortOrder',
    },
    total=True
)

_Notification_read_OrderByInput = TypedDict(
    '_Notification_read_OrderByInput',
    {
        'read': 'SortOrder',
    },
    total=True
)

_Notification_readAt_OrderByInput = TypedDict(
    '_Notification_readAt_OrderByInput',
    {
        'readAt': 'SortOrder',
    },
    total=True
)

_Notification_createdAt_OrderByInput = TypedDict(
    '_Notification_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Notification_updatedAt_OrderByInput = TypedDict(
    '_Notification_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Notification_RelevanceInner = TypedDict(
    '_Notification_RelevanceInner',
    {
        'fields': 'List[NotificationScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Notification_RelevanceOrderByInput = TypedDict(
    '_Notification_RelevanceOrderByInput',
    {
        '_relevance': '_Notification_RelevanceInner',
    },
    total=True
)

NotificationOrderByInput = Union[
    '_Notification_id_OrderByInput',
    '_Notification_type_OrderByInput',
    '_Notification_message_OrderByInput',
    '_Notification_priority_OrderByInput',
    '_Notification_targetUser_OrderByInput',
    '_Notification_metadata_OrderByInput',
    '_Notification_read_OrderByInput',
    '_Notification_readAt_OrderByInput',
    '_Notification_createdAt_OrderByInput',
    '_Notification_updatedAt_OrderByInput',
    '_Notification_RelevanceOrderByInput',
]



# recursive Notification types
# TODO: cleanup these types



NotificationRelationFilter = TypedDict(
    'NotificationRelationFilter',
    {
        'is': 'NotificationWhereInput',
        'is_not': 'NotificationWhereInput',
    },
    total=False,
)


class NotificationListRelationFilter(TypedDict, total=False):
    some: 'NotificationWhereInput'
    none: 'NotificationWhereInput'
    every: 'NotificationWhereInput'


class NotificationInclude(TypedDict, total=False):
    """Notification relational arguments"""


class AdminIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""


class AdminArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'AdminIncludeFromAdmin'


class FindManyAdminArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdmin'


class GuestIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    reservations: Union[bool, 'FindManyReservationArgsFromNotification']


class GuestArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'GuestIncludeFromGuest'


class FindManyGuestArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['GuestOrderByInput', List['GuestOrderByInput']]
    where: 'GuestWhereInput'
    cursor: 'GuestWhereUniqueInput'
    distinct: List['GuestScalarFieldKeys']
    include: 'GuestIncludeFromGuest'


class ReservationIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    guest: Union[bool, 'GuestArgsFromNotification']
    orders: Union[bool, 'FindManyOrderArgsFromNotification']
    payments: Union[bool, 'FindManyPaymentArgsFromNotification']


class ReservationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ReservationIncludeFromReservation'


class FindManyReservationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ReservationOrderByInput', List['ReservationOrderByInput']]
    where: 'ReservationWhereInput'
    cursor: 'ReservationWhereUniqueInput'
    distinct: List['ReservationScalarFieldKeys']
    include: 'ReservationIncludeFromReservation'


class ItemIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    orderItems: Union[bool, 'FindManyOrderItemArgsFromNotification']


class ItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'ItemIncludeFromItem'


class FindManyItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['ItemOrderByInput', List['ItemOrderByInput']]
    where: 'ItemWhereInput'
    cursor: 'ItemWhereUniqueInput'
    distinct: List['ItemScalarFieldKeys']
    include: 'ItemIncludeFromItem'


class OrderIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    reservation: Union[bool, 'ReservationArgsFromNotification']
    orderItems: Union[bool, 'FindManyOrderItemArgsFromNotification']
    payment: Union[bool, 'PaymentArgsFromNotification']


class OrderArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'OrderIncludeFromOrder'


class FindManyOrderArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['OrderOrderByInput', List['OrderOrderByInput']]
    where: 'OrderWhereInput'
    cursor: 'OrderWhereUniqueInput'
    distinct: List['OrderScalarFieldKeys']
    include: 'OrderIncludeFromOrder'


class OrderItemIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    order: Union[bool, 'OrderArgsFromNotification']
    item: Union[bool, 'ItemArgsFromNotification']


class OrderItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'OrderItemIncludeFromOrderItem'


class FindManyOrderItemArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['OrderItemOrderByInput', List['OrderItemOrderByInput']]
    where: 'OrderItemWhereInput'
    cursor: 'OrderItemWhereUniqueInput'
    distinct: List['OrderItemScalarFieldKeys']
    include: 'OrderItemIncludeFromOrderItem'


class PaymentIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""
    reservation: Union[bool, 'ReservationArgsFromNotification']
    orders: Union[bool, 'FindManyOrderArgsFromNotification']


class PaymentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'PaymentIncludeFromPayment'


class FindManyPaymentArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['PaymentOrderByInput', List['PaymentOrderByInput']]
    where: 'PaymentWhereInput'
    cursor: 'PaymentWhereUniqueInput'
    distinct: List['PaymentScalarFieldKeys']
    include: 'PaymentIncludeFromPayment'


class NotificationPreferenceIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""


class NotificationPreferenceArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class FindManyNotificationPreferenceArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['NotificationPreferenceOrderByInput', List['NotificationPreferenceOrderByInput']]
    where: 'NotificationPreferenceWhereInput'
    cursor: 'NotificationPreferenceWhereUniqueInput'
    distinct: List['NotificationPreferenceScalarFieldKeys']
    include: 'NotificationPreferenceIncludeFromNotificationPreference'


class NotificationIncludeFromNotification(TypedDict, total=False):
    """Relational arguments for Notification"""


class NotificationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    include: 'NotificationIncludeFromNotification'


class FindManyNotificationArgsFromNotification(TypedDict, total=False):
    """Arguments for Notification"""
    take: int
    skip: int
    order_by: Union['NotificationOrderByInput', List['NotificationOrderByInput']]
    where: 'NotificationWhereInput'
    cursor: 'NotificationWhereUniqueInput'
    distinct: List['NotificationScalarFieldKeys']
    include: 'NotificationIncludeFromNotification'




FindManyNotificationArgs = FindManyNotificationArgsFromNotification
FindFirstNotificationArgs = FindManyNotificationArgsFromNotification


class NotificationWhereInput(TypedDict, total=False):
    """Notification arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: 'enums.NotificationType'
    message: Union[_str, 'types.StringFilter']
    priority: Union[_str, 'types.StringFilter']
    targetUser: Union[None, _str, 'types.StringFilter']
    metadata: Union[None, 'fields.Json', 'types.JsonFilter']
    read: Union[_bool, 'types.BooleanFilter']
    readAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['NotificationWhereInput', List['NotificationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['NotificationWhereInput']
    OR: List['NotificationWhereInput']
    NOT: List['NotificationWhereInput']



# aggregate Notification types


class NotificationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Notification arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.NotificationType'
    message: Union[_str, 'types.StringWithAggregatesFilter']
    priority: Union[_str, 'types.StringWithAggregatesFilter']
    targetUser: Union[_str, 'types.StringWithAggregatesFilter']
    metadata: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    read: Union[_bool, 'types.BooleanWithAggregatesFilter']
    readAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['NotificationScalarWhereWithAggregatesInput']
    OR: List['NotificationScalarWhereWithAggregatesInput']
    NOT: List['NotificationScalarWhereWithAggregatesInput']



class NotificationGroupByOutput(TypedDict, total=False):
    id: _str
    type: 'enums.NotificationType'
    message: _str
    priority: _str
    targetUser: _str
    metadata: 'fields.Json'
    read: _bool
    readAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'NotificationSumAggregateOutput'
    _avg: 'NotificationAvgAggregateOutput'
    _min: 'NotificationMinAggregateOutput'
    _max: 'NotificationMaxAggregateOutput'
    _count: 'NotificationCountAggregateOutput'


class NotificationAvgAggregateOutput(TypedDict, total=False):
    """Notification output for aggregating averages"""


class NotificationSumAggregateOutput(TypedDict, total=False):
    """Notification output for aggregating sums"""


class NotificationScalarAggregateOutput(TypedDict, total=False):
    """Notification output including scalar fields"""
    id: _str
    type: 'enums.NotificationType'
    message: _str
    priority: _str
    targetUser: _str
    metadata: 'fields.Json'
    read: _bool
    readAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


NotificationMinAggregateOutput = NotificationScalarAggregateOutput
NotificationMaxAggregateOutput = NotificationScalarAggregateOutput


class NotificationMaxAggregateInput(TypedDict, total=False):
    """Notification input for aggregating by max"""
    id: bool
    type: bool
    message: bool
    priority: bool
    targetUser: bool
    metadata: bool
    read: bool
    readAt: bool
    createdAt: bool
    updatedAt: bool


class NotificationMinAggregateInput(TypedDict, total=False):
    """Notification input for aggregating by min"""
    id: bool
    type: bool
    message: bool
    priority: bool
    targetUser: bool
    metadata: bool
    read: bool
    readAt: bool
    createdAt: bool
    updatedAt: bool


class NotificationNumberAggregateInput(TypedDict, total=False):
    """Notification input for aggregating numbers"""


NotificationAvgAggregateInput = NotificationNumberAggregateInput
NotificationSumAggregateInput = NotificationNumberAggregateInput


NotificationCountAggregateInput = TypedDict(
    'NotificationCountAggregateInput',
    {
        'id': bool,
        'type': bool,
        'message': bool,
        'priority': bool,
        'targetUser': bool,
        'metadata': bool,
        'read': bool,
        'readAt': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

NotificationCountAggregateOutput = TypedDict(
    'NotificationCountAggregateOutput',
    {
        'id': int,
        'type': int,
        'message': int,
        'priority': int,
        'targetUser': int,
        'metadata': int,
        'read': int,
        'readAt': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


NotificationKeys = Literal[
    'id',
    'type',
    'message',
    'priority',
    'targetUser',
    'metadata',
    'read',
    'readAt',
    'createdAt',
    'updatedAt',
]
NotificationScalarFieldKeys = Literal[
    'id',
    'type',
    'message',
    'priority',
    'targetUser',
    'metadata',
    'read',
    'readAt',
    'createdAt',
    'updatedAt',
]
NotificationScalarFieldKeysT = TypeVar('NotificationScalarFieldKeysT', bound=NotificationScalarFieldKeys)

NotificationRelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields