# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class AdminActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Admin]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Admin.prisma().query_raw(
            'SELECT * FROM Admin WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Admin
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Admin.prisma().query_first(
            'SELECT * FROM Admin WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AdminCreateInput,
        include: Optional[types.AdminInclude] = None
    ) -> _PrismaModelT:
        """Create a new Admin record.

        Parameters
        ----------
        data
            Admin record data
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The created Admin record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Admin record from just the required fields
        admin = await Admin.prisma().create(
            data={
                # data to create a Admin record
                'email': 'ggciceaie',
                'password': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AdminCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Admin records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Admin record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Admin.prisma().create_many(
            data=[
                {
                    # data to create a Admin record
                    'email': 'cadfabfehe',
                    'password': 'dgiiaaijj',
                },
                {
                    # data to create a Admin record
                    'email': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Admin record.

        Parameters
        ----------
        where
            Admin filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The deleted Admin record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Admin record.

        Parameters
        ----------
        where
            Admin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The found Admin record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Admin record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Admin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The found Admin record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
        include: Optional[types.AdminInclude] = None,
        order: Optional[Union[types.AdminOrderByInput, List[types.AdminOrderByInput]]] = None,
        distinct: Optional[List[types.AdminScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Admin records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Admin records returned
        skip
            Ignore the first N results
        where
            Admin filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Admin model
        order
            Order the returned Admin records by any field
        distinct
            Filter Admin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Admin]
            The list of all Admin records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Admin records
        admins = await Admin.prisma().find_many(take=10)

        # find the first 5 Admin records ordered by the password field
        admins = await Admin.prisma().find_many(
            take=5,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
        include: Optional[types.AdminInclude] = None,
        order: Optional[Union[types.AdminOrderByInput, List[types.AdminOrderByInput]]] = None,
        distinct: Optional[List[types.AdminScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Admin record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Admin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Admin model
        order
            Order the returned Admin records by any field
        distinct
            Filter Admin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Admin
            The first Admin record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Admin record ordered by the createdAt field
        admin = await Admin.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
        include: Optional[types.AdminInclude] = None,
        order: Optional[Union[types.AdminOrderByInput, List[types.AdminOrderByInput]]] = None,
        distinct: Optional[List[types.AdminScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Admin record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Admin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Admin model
        order
            Order the returned Admin records by any field
        distinct
            Filter Admin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Admin
            The first Admin record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Admin record ordered by the updatedAt field
        admin = await Admin.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AdminUpdateInput,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Admin record.

        Parameters
        ----------
        data
            Admin record data specifying what to update
        where
            Admin filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The updated Admin record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        admin = await Admin.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the Admin record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AdminWhereUniqueInput,
        data: types.AdminUpsertInput,
        include: Optional[types.AdminInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Admin filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The created or updated Admin record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'email': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
                'update': {
                    'email': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AdminUpdateManyMutationInput,
        where: types.AdminWhereInput,
    ) -> int:
        """Update multiple Admin records

        Parameters
        ----------
        data
            Admin data to update the selected Admin records to
        where
            Filter to select the Admin records to update

        Returns
        -------
        int
            The total number of Admin records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Admin records
        total = await Admin.prisma().update_many(
            data={
                'id': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Admin records present in the database

        Parameters
        ----------
        select
            Select the Admin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Admin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdminCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Admin.prisma().count()

        # results: prisma.types.AdminCountAggregateOutput
        results = await Admin.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AdminCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
    ) -> types.AdminCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AdminCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
    ) -> Union[int, types.AdminCountAggregateOutput]:
        """Count the number of Admin records present in the database

        Parameters
        ----------
        select
            Select the Admin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Admin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdminCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Admin.prisma().count()

        # results: prisma.types.AdminCountAggregateOutput
        results = await Admin.prisma().count(
            select={
                '_all': True,
                'password': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AdminCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AdminWhereInput] = None
    ) -> int:
        """Delete multiple Admin records.

        Parameters
        ----------
        where
            Optional Admin filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Admin records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Admin records
        total = await Admin.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AdminScalarFieldKeysT'],
        *,
        where: Optional['types.AdminWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AdminAvgAggregateInput'] = None,
        sum: Optional['types.AdminSumAggregateInput'] = None,
        min: Optional['types.AdminMinAggregateInput'] = None,
        max: Optional['types.AdminMaxAggregateInput'] = None,
        having: Optional['types.AdminScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AdminCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AdminScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.AdminScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.AdminGroupByOutput']:
        """Group Admin records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Admin fields to group records by
        where
            Admin filter to select records
        take
            Limit the maximum number of Admin records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AdminGroupByOutput]
            A list of dictionaries representing the Admin record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Admin records by createdAt values
        # and count how many records are in each group
        results = await Admin.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GuestActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Guest]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Guest.prisma().query_raw(
            'SELECT * FROM Guest WHERE id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Guest
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Guest.prisma().query_first(
            'SELECT * FROM Guest WHERE name = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GuestCreateInput,
        include: Optional[types.GuestInclude] = None
    ) -> _PrismaModelT:
        """Create a new Guest record.

        Parameters
        ----------
        data
            Guest record data
        include
            Specifies which relations should be loaded on the returned Guest model

        Returns
        -------
        prisma.models.Guest
            The created Guest record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Guest record from just the required fields
        guest = await Guest.prisma().create(
            data={
                # data to create a Guest record
                'name': 'bgeecijdgg',
                'email': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GuestCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Guest records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Guest record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Guest.prisma().create_many(
            data=[
                {
                    # data to create a Guest record
                    'name': 'bgehebiafc',
                    'email': 'bghffegacj',
                },
                {
                    # data to create a Guest record
                    'name': 'bhghchehcc',
                    'email': 'dcgchcbbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GuestWhereUniqueInput,
        include: Optional[types.GuestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Guest record.

        Parameters
        ----------
        where
            Guest filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Guest model

        Returns
        -------
        prisma.models.Guest
            The deleted Guest record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guest = await Guest.prisma().delete(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GuestWhereUniqueInput,
        include: Optional[types.GuestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Guest record.

        Parameters
        ----------
        where
            Guest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Guest model

        Returns
        -------
        prisma.models.Guest
            The found Guest record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guest = await Guest.prisma().find_unique(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GuestWhereUniqueInput,
        include: Optional[types.GuestInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Guest record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Guest filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Guest model

        Returns
        -------
        prisma.models.Guest
            The found Guest record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guest = await Guest.prisma().find_unique_or_raise(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuestWhereInput] = None,
        cursor: Optional[types.GuestWhereUniqueInput] = None,
        include: Optional[types.GuestInclude] = None,
        order: Optional[Union[types.GuestOrderByInput, List[types.GuestOrderByInput]]] = None,
        distinct: Optional[List[types.GuestScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Guest records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Guest records returned
        skip
            Ignore the first N results
        where
            Guest filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Guest model
        order
            Order the returned Guest records by any field
        distinct
            Filter Guest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Guest]
            The list of all Guest records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Guest records
        guests = await Guest.prisma().find_many(take=10)

        # find the first 5 Guest records ordered by the email field
        guests = await Guest.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GuestWhereInput] = None,
        cursor: Optional[types.GuestWhereUniqueInput] = None,
        include: Optional[types.GuestInclude] = None,
        order: Optional[Union[types.GuestOrderByInput, List[types.GuestOrderByInput]]] = None,
        distinct: Optional[List[types.GuestScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Guest record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Guest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Guest model
        order
            Order the returned Guest records by any field
        distinct
            Filter Guest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Guest
            The first Guest record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Guest record ordered by the phoneNumber field
        guest = await Guest.prisma().find_first(
            skip=1,
            order={
                'phoneNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GuestWhereInput] = None,
        cursor: Optional[types.GuestWhereUniqueInput] = None,
        include: Optional[types.GuestInclude] = None,
        order: Optional[Union[types.GuestOrderByInput, List[types.GuestOrderByInput]]] = None,
        distinct: Optional[List[types.GuestScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Guest record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Guest filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Guest model
        order
            Order the returned Guest records by any field
        distinct
            Filter Guest records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Guest
            The first Guest record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Guest record ordered by the preferences field
        guest = await Guest.prisma().find_first_or_raise(
            skip=1,
            order={
                'preferences': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GuestUpdateInput,
        where: types.GuestWhereUniqueInput,
        include: Optional[types.GuestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Guest record.

        Parameters
        ----------
        data
            Guest record data specifying what to update
        where
            Guest filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Guest model

        Returns
        -------
        prisma.models.Guest
            The updated Guest record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        guest = await Guest.prisma().update(
            where={
                'id': 'bjgjgibgbf',
            },
            data={
                # data to update the Guest record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GuestWhereUniqueInput,
        data: types.GuestUpsertInput,
        include: Optional[types.GuestInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Guest filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Guest model

        Returns
        -------
        prisma.models.Guest
            The created or updated Guest record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guest = await Guest.prisma().upsert(
            where={
                'id': 'bbbgbhfjge',
            },
            data={
                'create': {
                    'id': 'bbbgbhfjge',
                    'name': 'bhghchehcc',
                    'email': 'dcgchcbbf',
                },
                'update': {
                    'name': 'bhghchehcc',
                    'email': 'dcgchcbbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GuestUpdateManyMutationInput,
        where: types.GuestWhereInput,
    ) -> int:
        """Update multiple Guest records

        Parameters
        ----------
        data
            Guest data to update the selected Guest records to
        where
            Filter to select the Guest records to update

        Returns
        -------
        int
            The total number of Guest records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Guest records
        total = await Guest.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuestWhereInput] = None,
        cursor: Optional[types.GuestWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Guest records present in the database

        Parameters
        ----------
        select
            Select the Guest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Guest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GuestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Guest.prisma().count()

        # results: prisma.types.GuestCountAggregateOutput
        results = await Guest.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GuestCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuestWhereInput] = None,
        cursor: Optional[types.GuestWhereUniqueInput] = None,
    ) -> types.GuestCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GuestCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuestWhereInput] = None,
        cursor: Optional[types.GuestWhereUniqueInput] = None,
    ) -> Union[int, types.GuestCountAggregateOutput]:
        """Count the number of Guest records present in the database

        Parameters
        ----------
        select
            Select the Guest fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Guest filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GuestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Guest.prisma().count()

        # results: prisma.types.GuestCountAggregateOutput
        results = await Guest.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GuestCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GuestWhereInput] = None
    ) -> int:
        """Delete multiple Guest records.

        Parameters
        ----------
        where
            Optional Guest filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Guest records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Guest records
        total = await Guest.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GuestScalarFieldKeysT'],
        *,
        where: Optional['types.GuestWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GuestAvgAggregateInput'] = None,
        sum: Optional['types.GuestSumAggregateInput'] = None,
        min: Optional['types.GuestMinAggregateInput'] = None,
        max: Optional['types.GuestMaxAggregateInput'] = None,
        having: Optional['types.GuestScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GuestCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GuestScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.GuestScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.GuestGroupByOutput']:
        """Group Guest records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Guest fields to group records by
        where
            Guest filter to select records
        take
            Limit the maximum number of Guest records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GuestGroupByOutput]
            A list of dictionaries representing the Guest record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Guest records by name values
        # and count how many records are in each group
        results = await Guest.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReservationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Reservation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Reservation.prisma().query_raw(
            'SELECT * FROM Reservation WHERE id = $1',
            'igbehcbab',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Reservation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Reservation.prisma().query_first(
            'SELECT * FROM Reservation WHERE startDate = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReservationCreateInput,
        include: Optional[types.ReservationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Reservation record.

        Parameters
        ----------
        data
            Reservation record data
        include
            Specifies which relations should be loaded on the returned Reservation model

        Returns
        -------
        prisma.models.Reservation
            The created Reservation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Reservation record from just the required fields
        reservation = await Reservation.prisma().create(
            data={
                # data to create a Reservation record
                'startDate': datetime.datetime.utcnow(),
                'endDate': datetime.datetime.utcnow(),
                'pinCode': 'bdadaadhag',
                'guestId': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReservationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Reservation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Reservation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Reservation.prisma().create_many(
            data=[
                {
                    # data to create a Reservation record
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                    'pinCode': 'caaaedabfc',
                    'guestId': 'bigibebcib',
                },
                {
                    # data to create a Reservation record
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                    'pinCode': 'bigaiehgcc',
                    'guestId': 'beeifcbebf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReservationWhereUniqueInput,
        include: Optional[types.ReservationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Reservation record.

        Parameters
        ----------
        where
            Reservation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Reservation model

        Returns
        -------
        prisma.models.Reservation
            The deleted Reservation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reservation = await Reservation.prisma().delete(
            where={
                'id': 'bgcigfahea',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReservationWhereUniqueInput,
        include: Optional[types.ReservationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Reservation record.

        Parameters
        ----------
        where
            Reservation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Reservation model

        Returns
        -------
        prisma.models.Reservation
            The found Reservation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reservation = await Reservation.prisma().find_unique(
            where={
                'id': 'bcejgaggif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReservationWhereUniqueInput,
        include: Optional[types.ReservationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Reservation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Reservation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Reservation model

        Returns
        -------
        prisma.models.Reservation
            The found Reservation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reservation = await Reservation.prisma().find_unique_or_raise(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReservationWhereInput] = None,
        cursor: Optional[types.ReservationWhereUniqueInput] = None,
        include: Optional[types.ReservationInclude] = None,
        order: Optional[Union[types.ReservationOrderByInput, List[types.ReservationOrderByInput]]] = None,
        distinct: Optional[List[types.ReservationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Reservation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Reservation records returned
        skip
            Ignore the first N results
        where
            Reservation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Reservation model
        order
            Order the returned Reservation records by any field
        distinct
            Filter Reservation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Reservation]
            The list of all Reservation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Reservation records
        reservations = await Reservation.prisma().find_many(take=10)

        # find the first 5 Reservation records ordered by the endDate field
        reservations = await Reservation.prisma().find_many(
            take=5,
            order={
                'endDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReservationWhereInput] = None,
        cursor: Optional[types.ReservationWhereUniqueInput] = None,
        include: Optional[types.ReservationInclude] = None,
        order: Optional[Union[types.ReservationOrderByInput, List[types.ReservationOrderByInput]]] = None,
        distinct: Optional[List[types.ReservationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Reservation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Reservation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Reservation model
        order
            Order the returned Reservation records by any field
        distinct
            Filter Reservation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Reservation
            The first Reservation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Reservation record ordered by the pinCode field
        reservation = await Reservation.prisma().find_first(
            skip=1,
            order={
                'pinCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReservationWhereInput] = None,
        cursor: Optional[types.ReservationWhereUniqueInput] = None,
        include: Optional[types.ReservationInclude] = None,
        order: Optional[Union[types.ReservationOrderByInput, List[types.ReservationOrderByInput]]] = None,
        distinct: Optional[List[types.ReservationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Reservation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Reservation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Reservation model
        order
            Order the returned Reservation records by any field
        distinct
            Filter Reservation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Reservation
            The first Reservation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Reservation record ordered by the status field
        reservation = await Reservation.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReservationUpdateInput,
        where: types.ReservationWhereUniqueInput,
        include: Optional[types.ReservationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Reservation record.

        Parameters
        ----------
        data
            Reservation record data specifying what to update
        where
            Reservation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Reservation model

        Returns
        -------
        prisma.models.Reservation
            The updated Reservation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        reservation = await Reservation.prisma().update(
            where={
                'id': 'hgdhbjhhj',
            },
            data={
                # data to update the Reservation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReservationWhereUniqueInput,
        data: types.ReservationUpsertInput,
        include: Optional[types.ReservationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Reservation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Reservation model

        Returns
        -------
        prisma.models.Reservation
            The created or updated Reservation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reservation = await Reservation.prisma().upsert(
            where={
                'id': 'ecjjjfbae',
            },
            data={
                'create': {
                    'id': 'ecjjjfbae',
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                    'pinCode': 'bigaiehgcc',
                    'guestId': 'beeifcbebf',
                },
                'update': {
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                    'pinCode': 'bigaiehgcc',
                    'guestId': 'beeifcbebf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReservationUpdateManyMutationInput,
        where: types.ReservationWhereInput,
    ) -> int:
        """Update multiple Reservation records

        Parameters
        ----------
        data
            Reservation data to update the selected Reservation records to
        where
            Filter to select the Reservation records to update

        Returns
        -------
        int
            The total number of Reservation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Reservation records
        total = await Reservation.prisma().update_many(
            data={
                'roomNumber': 'bhhfibbigf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReservationWhereInput] = None,
        cursor: Optional[types.ReservationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Reservation records present in the database

        Parameters
        ----------
        select
            Select the Reservation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Reservation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReservationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Reservation.prisma().count()

        # results: prisma.types.ReservationCountAggregateOutput
        results = await Reservation.prisma().count(
            select={
                '_all': True,
                'guestId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReservationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReservationWhereInput] = None,
        cursor: Optional[types.ReservationWhereUniqueInput] = None,
    ) -> types.ReservationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReservationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReservationWhereInput] = None,
        cursor: Optional[types.ReservationWhereUniqueInput] = None,
    ) -> Union[int, types.ReservationCountAggregateOutput]:
        """Count the number of Reservation records present in the database

        Parameters
        ----------
        select
            Select the Reservation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Reservation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReservationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Reservation.prisma().count()

        # results: prisma.types.ReservationCountAggregateOutput
        results = await Reservation.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReservationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReservationWhereInput] = None
    ) -> int:
        """Delete multiple Reservation records.

        Parameters
        ----------
        where
            Optional Reservation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Reservation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Reservation records
        total = await Reservation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReservationScalarFieldKeysT'],
        *,
        where: Optional['types.ReservationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReservationAvgAggregateInput'] = None,
        sum: Optional['types.ReservationSumAggregateInput'] = None,
        min: Optional['types.ReservationMinAggregateInput'] = None,
        max: Optional['types.ReservationMaxAggregateInput'] = None,
        having: Optional['types.ReservationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReservationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReservationScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ReservationScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ReservationGroupByOutput']:
        """Group Reservation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Reservation fields to group records by
        where
            Reservation filter to select records
        take
            Limit the maximum number of Reservation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReservationGroupByOutput]
            A list of dictionaries representing the Reservation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Reservation records by updatedAt values
        # and count how many records are in each group
        results = await Reservation.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Item]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Item.prisma().query_raw(
            'SELECT * FROM Item WHERE id = $1',
            'ijdbeffgg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Item
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Item.prisma().query_first(
            'SELECT * FROM Item WHERE name = $1',
            'jjfeafhfj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ItemCreateInput,
        include: Optional[types.ItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new Item record.

        Parameters
        ----------
        data
            Item record data
        include
            Specifies which relations should be loaded on the returned Item model

        Returns
        -------
        prisma.models.Item
            The created Item record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Item record from just the required fields
        item = await Item.prisma().create(
            data={
                # data to create a Item record
                'name': 'cbachdgfce',
                'price': Decimal('271520213.45663'),
                'qrCode': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Item records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Item record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Item.prisma().create_many(
            data=[
                {
                    # data to create a Item record
                    'name': 'bfidgijfjc',
                    'price': Decimal('878442065.167528'),
                    'qrCode': 'bgchfhgceh',
                },
                {
                    # data to create a Item record
                    'name': 'cafeiaccbc',
                    'price': Decimal('60335757.68446'),
                    'qrCode': 'bgcffadich',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ItemWhereUniqueInput,
        include: Optional[types.ItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Item record.

        Parameters
        ----------
        where
            Item filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Item model

        Returns
        -------
        prisma.models.Item
            The deleted Item record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        item = await Item.prisma().delete(
            where={
                'id': 'fcbichhci',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ItemWhereUniqueInput,
        include: Optional[types.ItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Item record.

        Parameters
        ----------
        where
            Item filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Item model

        Returns
        -------
        prisma.models.Item
            The found Item record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        item = await Item.prisma().find_unique(
            where={
                'id': 'bcggadccgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ItemWhereUniqueInput,
        include: Optional[types.ItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Item record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Item filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Item model

        Returns
        -------
        prisma.models.Item
            The found Item record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        item = await Item.prisma().find_unique_or_raise(
            where={
                'id': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemWhereInput] = None,
        cursor: Optional[types.ItemWhereUniqueInput] = None,
        include: Optional[types.ItemInclude] = None,
        order: Optional[Union[types.ItemOrderByInput, List[types.ItemOrderByInput]]] = None,
        distinct: Optional[List[types.ItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Item records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Item records returned
        skip
            Ignore the first N results
        where
            Item filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Item model
        order
            Order the returned Item records by any field
        distinct
            Filter Item records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Item]
            The list of all Item records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Item records
        items = await Item.prisma().find_many(take=10)

        # find the first 5 Item records ordered by the price field
        items = await Item.prisma().find_many(
            take=5,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ItemWhereInput] = None,
        cursor: Optional[types.ItemWhereUniqueInput] = None,
        include: Optional[types.ItemInclude] = None,
        order: Optional[Union[types.ItemOrderByInput, List[types.ItemOrderByInput]]] = None,
        distinct: Optional[List[types.ItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Item record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Item filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Item model
        order
            Order the returned Item records by any field
        distinct
            Filter Item records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Item
            The first Item record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Item record ordered by the qrCode field
        item = await Item.prisma().find_first(
            skip=1,
            order={
                'qrCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ItemWhereInput] = None,
        cursor: Optional[types.ItemWhereUniqueInput] = None,
        include: Optional[types.ItemInclude] = None,
        order: Optional[Union[types.ItemOrderByInput, List[types.ItemOrderByInput]]] = None,
        distinct: Optional[List[types.ItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Item record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Item filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Item model
        order
            Order the returned Item records by any field
        distinct
            Filter Item records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Item
            The first Item record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Item record ordered by the description field
        item = await Item.prisma().find_first_or_raise(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ItemUpdateInput,
        where: types.ItemWhereUniqueInput,
        include: Optional[types.ItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Item record.

        Parameters
        ----------
        data
            Item record data specifying what to update
        where
            Item filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Item model

        Returns
        -------
        prisma.models.Item
            The updated Item record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        item = await Item.prisma().update(
            where={
                'id': 'cafdaehjid',
            },
            data={
                # data to update the Item record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ItemWhereUniqueInput,
        data: types.ItemUpsertInput,
        include: Optional[types.ItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Item filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Item model

        Returns
        -------
        prisma.models.Item
            The created or updated Item record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        item = await Item.prisma().upsert(
            where={
                'id': 'gifdddbia',
            },
            data={
                'create': {
                    'id': 'gifdddbia',
                    'name': 'cafeiaccbc',
                    'price': Decimal('60335757.68446'),
                    'qrCode': 'bgcffadich',
                },
                'update': {
                    'name': 'cafeiaccbc',
                    'price': Decimal('60335757.68446'),
                    'qrCode': 'bgcffadich',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ItemUpdateManyMutationInput,
        where: types.ItemWhereInput,
    ) -> int:
        """Update multiple Item records

        Parameters
        ----------
        data
            Item data to update the selected Item records to
        where
            Filter to select the Item records to update

        Returns
        -------
        int
            The total number of Item records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Item records
        total = await Item.prisma().update_many(
            data={
                'category': 'bchehecef'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemWhereInput] = None,
        cursor: Optional[types.ItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Item records present in the database

        Parameters
        ----------
        select
            Select the Item fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Item filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Item.prisma().count()

        # results: prisma.types.ItemCountAggregateOutput
        results = await Item.prisma().count(
            select={
                '_all': True,
                'available': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemWhereInput] = None,
        cursor: Optional[types.ItemWhereUniqueInput] = None,
    ) -> types.ItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ItemWhereInput] = None,
        cursor: Optional[types.ItemWhereUniqueInput] = None,
    ) -> Union[int, types.ItemCountAggregateOutput]:
        """Count the number of Item records present in the database

        Parameters
        ----------
        select
            Select the Item fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Item filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Item.prisma().count()

        # results: prisma.types.ItemCountAggregateOutput
        results = await Item.prisma().count(
            select={
                '_all': True,
                'stockLevel': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ItemWhereInput] = None
    ) -> int:
        """Delete multiple Item records.

        Parameters
        ----------
        where
            Optional Item filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Item records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Item records
        total = await Item.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ItemScalarFieldKeysT'],
        *,
        where: Optional['types.ItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ItemAvgAggregateInput'] = None,
        sum: Optional['types.ItemSumAggregateInput'] = None,
        min: Optional['types.ItemMinAggregateInput'] = None,
        max: Optional['types.ItemMaxAggregateInput'] = None,
        having: Optional['types.ItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ItemScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ItemScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ItemGroupByOutput']:
        """Group Item records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Item fields to group records by
        where
            Item filter to select records
        take
            Limit the maximum number of Item records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ItemGroupByOutput]
            A list of dictionaries representing the Item record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Item records by imageUrl values
        # and count how many records are in each group
        results = await Item.prisma().group_by(
            ['imageUrl'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Order]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Order.prisma().query_raw(
            'SELECT * FROM Order WHERE id = $1',
            'jeijcbhfe',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Order
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Order.prisma().query_first(
            'SELECT * FROM Order WHERE reservationId = $1',
            'bjgejjabff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrderCreateInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new Order record.

        Parameters
        ----------
        data
            Order record data
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created Order record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Order record from just the required fields
        order = await Order.prisma().create(
            data={
                # data to create a Order record
                'reservationId': 'bcciijbibg',
                'totalAmount': Decimal('255202753.122357'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Order records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Order record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Order.prisma().create_many(
            data=[
                {
                    # data to create a Order record
                    'reservationId': 'febcgjbfj',
                    'totalAmount': Decimal('1064846676.50838'),
                },
                {
                    # data to create a Order record
                    'reservationId': 'bacecgfhbe',
                    'totalAmount': Decimal('872078403.187474'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Order record.

        Parameters
        ----------
        where
            Order filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The deleted Order record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().delete(
            where={
                'id': 'jbgijghgb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Order record.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique(
            where={
                'id': 'hgjcghfbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Order record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Order filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The found Order record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().find_unique_or_raise(
            where={
                'id': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Order records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N results
        where
            Order filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Order]
            The list of all Order records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Order records
        orders = await Order.prisma().find_many(take=10)

        # find the first 5 Order records ordered by the totalAmount field
        orders = await Order.prisma().find_many(
            take=5,
            order={
                'totalAmount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Order record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the status field
        order = await Order.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
        include: Optional[types.OrderInclude] = None,
        order: Optional[Union[types.OrderOrderByInput, List[types.OrderOrderByInput]]] = None,
        distinct: Optional[List[types.OrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Order record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Order filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Order model
        order
            Order the returned Order records by any field
        distinct
            Filter Order records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Order
            The first Order record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Order record ordered by the paymentId field
        order = await Order.prisma().find_first_or_raise(
            skip=1,
            order={
                'paymentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrderUpdateInput,
        where: types.OrderWhereUniqueInput,
        include: Optional[types.OrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Order record.

        Parameters
        ----------
        data
            Order record data specifying what to update
        where
            Order filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The updated Order record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        order = await Order.prisma().update(
            where={
                'id': 'jchciaee',
            },
            data={
                # data to update the Order record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrderWhereUniqueInput,
        data: types.OrderUpsertInput,
        include: Optional[types.OrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Order filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Order model

        Returns
        -------
        prisma.models.Order
            The created or updated Order record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        order = await Order.prisma().upsert(
            where={
                'id': 'deeificjd',
            },
            data={
                'create': {
                    'id': 'deeificjd',
                    'reservationId': 'bacecgfhbe',
                    'totalAmount': Decimal('872078403.187474'),
                },
                'update': {
                    'reservationId': 'bacecgfhbe',
                    'totalAmount': Decimal('872078403.187474'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrderUpdateManyMutationInput,
        where: types.OrderWhereInput,
    ) -> int:
        """Update multiple Order records

        Parameters
        ----------
        data
            Order data to update the selected Order records to
        where
            Filter to select the Order records to update

        Returns
        -------
        int
            The total number of Order records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Order records
        total = await Order.prisma().update_many(
            data={
                'notes': 'bbcbhebbda'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> types.OrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderWhereInput] = None,
        cursor: Optional[types.OrderWhereUniqueInput] = None,
    ) -> Union[int, types.OrderCountAggregateOutput]:
        """Count the number of Order records present in the database

        Parameters
        ----------
        select
            Select the Order fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Order filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Order.prisma().count()

        # results: prisma.types.OrderCountAggregateOutput
        results = await Order.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrderWhereInput] = None
    ) -> int:
        """Delete multiple Order records.

        Parameters
        ----------
        where
            Optional Order filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Order records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Order records
        total = await Order.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrderScalarFieldKeysT'],
        *,
        where: Optional['types.OrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrderAvgAggregateInput'] = None,
        sum: Optional['types.OrderSumAggregateInput'] = None,
        min: Optional['types.OrderMinAggregateInput'] = None,
        max: Optional['types.OrderMaxAggregateInput'] = None,
        having: Optional['types.OrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrderScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.OrderScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.OrderGroupByOutput']:
        """Group Order records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Order fields to group records by
        where
            Order filter to select records
        take
            Limit the maximum number of Order records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrderGroupByOutput]
            A list of dictionaries representing the Order record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Order records by id values
        # and count how many records are in each group
        results = await Order.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrderItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OrderItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OrderItem.prisma().query_raw(
            'SELECT * FROM OrderItem WHERE id = $1',
            'bejfijgcfb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OrderItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OrderItem.prisma().query_first(
            'SELECT * FROM OrderItem WHERE orderId = $1',
            'caifcbgii',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrderItemCreateInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new OrderItem record.

        Parameters
        ----------
        data
            OrderItem record data
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The created OrderItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OrderItem record from just the required fields
        orderitem = await OrderItem.prisma().create(
            data={
                # data to create a OrderItem record
                'orderId': 'igaibbfgj',
                'itemId': 'bggajdcbbi',
                'quantity': 525761943,
                'price': Decimal('736209796.49390'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrderItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OrderItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OrderItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OrderItem.prisma().create_many(
            data=[
                {
                    # data to create a OrderItem record
                    'orderId': 'gdjgigfgc',
                    'itemId': 'gfeaahdeh',
                    'quantity': 1905261552,
                    'price': Decimal('78746985.139832'),
                },
                {
                    # data to create a OrderItem record
                    'orderId': 'ifgaaagff',
                    'itemId': 'befcddgjce',
                    'quantity': 1573199653,
                    'price': Decimal('2013903098.50096'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OrderItem record.

        Parameters
        ----------
        where
            OrderItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The deleted OrderItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().delete(
            where={
                'id': 'biaagcedjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OrderItem record.

        Parameters
        ----------
        where
            OrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The found OrderItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().find_unique(
            where={
                'id': 'cahhaghecf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OrderItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The found OrderItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().find_unique_or_raise(
            where={
                'id': 'bghcbbcidi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
        include: Optional[types.OrderItemInclude] = None,
        order: Optional[Union[types.OrderItemOrderByInput, List[types.OrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.OrderItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OrderItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OrderItem records returned
        skip
            Ignore the first N results
        where
            OrderItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrderItem model
        order
            Order the returned OrderItem records by any field
        distinct
            Filter OrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OrderItem]
            The list of all OrderItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OrderItem records
        orderitems = await OrderItem.prisma().find_many(take=10)

        # find the first 5 OrderItem records ordered by the itemId field
        orderitems = await OrderItem.prisma().find_many(
            take=5,
            order={
                'itemId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
        include: Optional[types.OrderItemInclude] = None,
        order: Optional[Union[types.OrderItemOrderByInput, List[types.OrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.OrderItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OrderItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrderItem model
        order
            Order the returned OrderItem records by any field
        distinct
            Filter OrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrderItem
            The first OrderItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrderItem record ordered by the quantity field
        orderitem = await OrderItem.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
        include: Optional[types.OrderItemInclude] = None,
        order: Optional[Union[types.OrderItemOrderByInput, List[types.OrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.OrderItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OrderItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrderItem model
        order
            Order the returned OrderItem records by any field
        distinct
            Filter OrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrderItem
            The first OrderItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrderItem record ordered by the price field
        orderitem = await OrderItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrderItemUpdateInput,
        where: types.OrderItemWhereUniqueInput,
        include: Optional[types.OrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OrderItem record.

        Parameters
        ----------
        data
            OrderItem record data specifying what to update
        where
            OrderItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The updated OrderItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().update(
            where={
                'id': 'jcgghhgdj',
            },
            data={
                # data to update the OrderItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrderItemWhereUniqueInput,
        data: types.OrderItemUpsertInput,
        include: Optional[types.OrderItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OrderItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OrderItem model

        Returns
        -------
        prisma.models.OrderItem
            The created or updated OrderItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        orderitem = await OrderItem.prisma().upsert(
            where={
                'id': 'beehgcebbg',
            },
            data={
                'create': {
                    'id': 'beehgcebbg',
                    'orderId': 'ifgaaagff',
                    'itemId': 'befcddgjce',
                    'quantity': 1573199653,
                    'price': Decimal('2013903098.50096'),
                },
                'update': {
                    'orderId': 'ifgaaagff',
                    'itemId': 'befcddgjce',
                    'quantity': 1573199653,
                    'price': Decimal('2013903098.50096'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrderItemUpdateManyMutationInput,
        where: types.OrderItemWhereInput,
    ) -> int:
        """Update multiple OrderItem records

        Parameters
        ----------
        data
            OrderItem data to update the selected OrderItem records to
        where
            Filter to select the OrderItem records to update

        Returns
        -------
        int
            The total number of OrderItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OrderItem records
        total = await OrderItem.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OrderItem records present in the database

        Parameters
        ----------
        select
            Select the OrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrderItem.prisma().count()

        # results: prisma.types.OrderItemCountAggregateOutput
        results = await OrderItem.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrderItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
    ) -> types.OrderItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrderItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrderItemWhereInput] = None,
        cursor: Optional[types.OrderItemWhereUniqueInput] = None,
    ) -> Union[int, types.OrderItemCountAggregateOutput]:
        """Count the number of OrderItem records present in the database

        Parameters
        ----------
        select
            Select the OrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrderItem.prisma().count()

        # results: prisma.types.OrderItemCountAggregateOutput
        results = await OrderItem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrderItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrderItemWhereInput] = None
    ) -> int:
        """Delete multiple OrderItem records.

        Parameters
        ----------
        where
            Optional OrderItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OrderItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OrderItem records
        total = await OrderItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrderItemScalarFieldKeysT'],
        *,
        where: Optional['types.OrderItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrderItemAvgAggregateInput'] = None,
        sum: Optional['types.OrderItemSumAggregateInput'] = None,
        min: Optional['types.OrderItemMinAggregateInput'] = None,
        max: Optional['types.OrderItemMaxAggregateInput'] = None,
        having: Optional['types.OrderItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrderItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrderItemScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.OrderItemScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.OrderItemGroupByOutput']:
        """Group OrderItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OrderItem fields to group records by
        where
            OrderItem filter to select records
        take
            Limit the maximum number of OrderItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrderItemGroupByOutput]
            A list of dictionaries representing the OrderItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OrderItem records by orderId values
        # and count how many records are in each group
        results = await OrderItem.prisma().group_by(
            ['orderId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PaymentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Payment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Payment.prisma().query_raw(
            'SELECT * FROM Payment WHERE id = $1',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Payment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Payment.prisma().query_first(
            'SELECT * FROM Payment WHERE reservationId = $1',
            'deajegcfi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PaymentCreateInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Payment record.

        Parameters
        ----------
        data
            Payment record data
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created Payment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Payment record from just the required fields
        payment = await Payment.prisma().create(
            data={
                # data to create a Payment record
                'reservationId': 'gabahhhjf',
                'amount': Decimal('290603296.185582'),
                'method': 'bgbbaajbic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PaymentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Payment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Payment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Payment.prisma().create_many(
            data=[
                {
                    # data to create a Payment record
                    'reservationId': 'eegghdhjb',
                    'amount': Decimal('300568396.63262'),
                    'method': 'bhceabbgja',
                },
                {
                    # data to create a Payment record
                    'reservationId': 'ehabfhegh',
                    'amount': Decimal('1209209912.153674'),
                    'method': 'ececbijji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Payment record.

        Parameters
        ----------
        where
            Payment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The deleted Payment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().delete(
            where={
                'id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Payment record.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique(
            where={
                'id': 'fdgjfbhia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Payment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique_or_raise(
            where={
                'id': 'jcehcdchh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Payment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N results
        where
            Payment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Payment]
            The list of all Payment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Payment records
        payments = await Payment.prisma().find_many(take=10)

        # find the first 5 Payment records ordered by the amount field
        payments = await Payment.prisma().find_many(
            take=5,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Payment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the status field
        payment = await Payment.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Payment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the method field
        payment = await Payment.prisma().find_first_or_raise(
            skip=1,
            order={
                'method': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PaymentUpdateInput,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Payment record.

        Parameters
        ----------
        data
            Payment record data specifying what to update
        where
            Payment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The updated Payment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        payment = await Payment.prisma().update(
            where={
                'id': 'bgcbjdhjcc',
            },
            data={
                # data to update the Payment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PaymentWhereUniqueInput,
        data: types.PaymentUpsertInput,
        include: Optional[types.PaymentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Payment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created or updated Payment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().upsert(
            where={
                'id': 'bieiidcabj',
            },
            data={
                'create': {
                    'id': 'bieiidcabj',
                    'reservationId': 'ehabfhegh',
                    'amount': Decimal('1209209912.153674'),
                    'method': 'ececbijji',
                },
                'update': {
                    'reservationId': 'ehabfhegh',
                    'amount': Decimal('1209209912.153674'),
                    'method': 'ececbijji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PaymentUpdateManyMutationInput,
        where: types.PaymentWhereInput,
    ) -> int:
        """Update multiple Payment records

        Parameters
        ----------
        data
            Payment data to update the selected Payment records to
        where
            Filter to select the Payment records to update

        Returns
        -------
        int
            The total number of Payment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Payment records
        total = await Payment.prisma().update_many(
            data={
                'transactionId': 'bjcbfcieaa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PaymentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> types.PaymentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PaymentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> Union[int, types.PaymentCountAggregateOutput]:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PaymentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PaymentWhereInput] = None
    ) -> int:
        """Delete multiple Payment records.

        Parameters
        ----------
        where
            Optional Payment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Payment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Payment records
        total = await Payment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PaymentScalarFieldKeysT'],
        *,
        where: Optional['types.PaymentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PaymentAvgAggregateInput'] = None,
        sum: Optional['types.PaymentSumAggregateInput'] = None,
        min: Optional['types.PaymentMinAggregateInput'] = None,
        max: Optional['types.PaymentMaxAggregateInput'] = None,
        having: Optional['types.PaymentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PaymentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PaymentScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PaymentScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PaymentGroupByOutput']:
        """Group Payment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Payment fields to group records by
        where
            Payment filter to select records
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PaymentGroupByOutput]
            A list of dictionaries representing the Payment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Payment records by id values
        # and count how many records are in each group
        results = await Payment.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationPreferenceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.NotificationPreference]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await NotificationPreference.prisma().query_raw(
            'SELECT * FROM NotificationPreference WHERE id = $1',
            'cbaaechiej',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.NotificationPreference
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await NotificationPreference.prisma().query_first(
            'SELECT * FROM NotificationPreference WHERE userId = $1',
            'iejbeaaeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationPreferenceCreateInput,
        include: Optional[types.NotificationPreferenceInclude] = None
    ) -> _PrismaModelT:
        """Create a new NotificationPreference record.

        Parameters
        ----------
        data
            NotificationPreference record data
        include
            Specifies which relations should be loaded on the returned NotificationPreference model

        Returns
        -------
        prisma.models.NotificationPreference
            The created NotificationPreference record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a NotificationPreference record from just the required fields
        notificationpreference = await NotificationPreference.prisma().create(
            data={
                # data to create a NotificationPreference record
                'userId': 'jcibfcbhf',
                'channels': Json({'chdadcaga': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationPreferenceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple NotificationPreference records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of NotificationPreference record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await NotificationPreference.prisma().create_many(
            data=[
                {
                    # data to create a NotificationPreference record
                    'userId': 'jicieifbh',
                    'channels': Json({'fbahdheji': True}),
                },
                {
                    # data to create a NotificationPreference record
                    'userId': 'cbbheiicgh',
                    'channels': Json({'beabjeejdg': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationPreferenceWhereUniqueInput,
        include: Optional[types.NotificationPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single NotificationPreference record.

        Parameters
        ----------
        where
            NotificationPreference filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned NotificationPreference model

        Returns
        -------
        prisma.models.NotificationPreference
            The deleted NotificationPreference record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notificationpreference = await NotificationPreference.prisma().delete(
            where={
                'id': 'bcjhgahffd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationPreferenceWhereUniqueInput,
        include: Optional[types.NotificationPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique NotificationPreference record.

        Parameters
        ----------
        where
            NotificationPreference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned NotificationPreference model

        Returns
        -------
        prisma.models.NotificationPreference
            The found NotificationPreference record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notificationpreference = await NotificationPreference.prisma().find_unique(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationPreferenceWhereUniqueInput,
        include: Optional[types.NotificationPreferenceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique NotificationPreference record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            NotificationPreference filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned NotificationPreference model

        Returns
        -------
        prisma.models.NotificationPreference
            The found NotificationPreference record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notificationpreference = await NotificationPreference.prisma().find_unique_or_raise(
            where={
                'id': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationPreferenceWhereInput] = None,
        cursor: Optional[types.NotificationPreferenceWhereUniqueInput] = None,
        include: Optional[types.NotificationPreferenceInclude] = None,
        order: Optional[Union[types.NotificationPreferenceOrderByInput, List[types.NotificationPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationPreferenceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple NotificationPreference records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of NotificationPreference records returned
        skip
            Ignore the first N results
        where
            NotificationPreference filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NotificationPreference model
        order
            Order the returned NotificationPreference records by any field
        distinct
            Filter NotificationPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.NotificationPreference]
            The list of all NotificationPreference records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 NotificationPreference records
        notificationpreferences = await NotificationPreference.prisma().find_many(take=10)

        # find the first 5 NotificationPreference records ordered by the channels field
        notificationpreferences = await NotificationPreference.prisma().find_many(
            take=5,
            order={
                'channels': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationPreferenceWhereInput] = None,
        cursor: Optional[types.NotificationPreferenceWhereUniqueInput] = None,
        include: Optional[types.NotificationPreferenceInclude] = None,
        order: Optional[Union[types.NotificationPreferenceOrderByInput, List[types.NotificationPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationPreferenceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single NotificationPreference record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            NotificationPreference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NotificationPreference model
        order
            Order the returned NotificationPreference records by any field
        distinct
            Filter NotificationPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.NotificationPreference
            The first NotificationPreference record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second NotificationPreference record ordered by the quietHours field
        notificationpreference = await NotificationPreference.prisma().find_first(
            skip=1,
            order={
                'quietHours': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationPreferenceWhereInput] = None,
        cursor: Optional[types.NotificationPreferenceWhereUniqueInput] = None,
        include: Optional[types.NotificationPreferenceInclude] = None,
        order: Optional[Union[types.NotificationPreferenceOrderByInput, List[types.NotificationPreferenceOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationPreferenceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single NotificationPreference record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            NotificationPreference filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned NotificationPreference model
        order
            Order the returned NotificationPreference records by any field
        distinct
            Filter NotificationPreference records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.NotificationPreference
            The first NotificationPreference record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second NotificationPreference record ordered by the enabled field
        notificationpreference = await NotificationPreference.prisma().find_first_or_raise(
            skip=1,
            order={
                'enabled': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationPreferenceUpdateInput,
        where: types.NotificationPreferenceWhereUniqueInput,
        include: Optional[types.NotificationPreferenceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single NotificationPreference record.

        Parameters
        ----------
        data
            NotificationPreference record data specifying what to update
        where
            NotificationPreference filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned NotificationPreference model

        Returns
        -------
        prisma.models.NotificationPreference
            The updated NotificationPreference record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notificationpreference = await NotificationPreference.prisma().update(
            where={
                'id': 'bgjgecfejc',
            },
            data={
                # data to update the NotificationPreference record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationPreferenceWhereUniqueInput,
        data: types.NotificationPreferenceUpsertInput,
        include: Optional[types.NotificationPreferenceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            NotificationPreference filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned NotificationPreference model

        Returns
        -------
        prisma.models.NotificationPreference
            The created or updated NotificationPreference record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notificationpreference = await NotificationPreference.prisma().upsert(
            where={
                'id': 'bgjcgchib',
            },
            data={
                'create': {
                    'id': 'bgjcgchib',
                    'userId': 'cbbheiicgh',
                    'channels': Json({'beabjeejdg': True}),
                },
                'update': {
                    'userId': 'cbbheiicgh',
                    'channels': Json({'beabjeejdg': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationPreferenceUpdateManyMutationInput,
        where: types.NotificationPreferenceWhereInput,
    ) -> int:
        """Update multiple NotificationPreference records

        Parameters
        ----------
        data
            NotificationPreference data to update the selected NotificationPreference records to
        where
            Filter to select the NotificationPreference records to update

        Returns
        -------
        int
            The total number of NotificationPreference records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all NotificationPreference records
        total = await NotificationPreference.prisma().update_many(
            data={
                'mutedUntil': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationPreferenceWhereInput] = None,
        cursor: Optional[types.NotificationPreferenceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of NotificationPreference records present in the database

        Parameters
        ----------
        select
            Select the NotificationPreference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NotificationPreference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationPreferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NotificationPreference.prisma().count()

        # results: prisma.types.NotificationPreferenceCountAggregateOutput
        results = await NotificationPreference.prisma().count(
            select={
                '_all': True,
                'priorityThreshold': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationPreferenceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationPreferenceWhereInput] = None,
        cursor: Optional[types.NotificationPreferenceWhereUniqueInput] = None,
    ) -> types.NotificationPreferenceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationPreferenceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationPreferenceWhereInput] = None,
        cursor: Optional[types.NotificationPreferenceWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationPreferenceCountAggregateOutput]:
        """Count the number of NotificationPreference records present in the database

        Parameters
        ----------
        select
            Select the NotificationPreference fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            NotificationPreference filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationPreferenceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await NotificationPreference.prisma().count()

        # results: prisma.types.NotificationPreferenceCountAggregateOutput
        results = await NotificationPreference.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationPreferenceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationPreferenceWhereInput] = None
    ) -> int:
        """Delete multiple NotificationPreference records.

        Parameters
        ----------
        where
            Optional NotificationPreference filter to find the records to be deleted

        Returns
        -------
        int
            The total number of NotificationPreference records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all NotificationPreference records
        total = await NotificationPreference.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationPreferenceScalarFieldKeysT'],
        *,
        where: Optional['types.NotificationPreferenceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationPreferenceAvgAggregateInput'] = None,
        sum: Optional['types.NotificationPreferenceSumAggregateInput'] = None,
        min: Optional['types.NotificationPreferenceMinAggregateInput'] = None,
        max: Optional['types.NotificationPreferenceMaxAggregateInput'] = None,
        having: Optional['types.NotificationPreferenceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationPreferenceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationPreferenceScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NotificationPreferenceScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationPreferenceGroupByOutput']:
        """Group NotificationPreference records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar NotificationPreference fields to group records by
        where
            NotificationPreference filter to select records
        take
            Limit the maximum number of NotificationPreference records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationPreferenceGroupByOutput]
            A list of dictionaries representing the NotificationPreference record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group NotificationPreference records by updatedAt values
        # and count how many records are in each group
        results = await NotificationPreference.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class NotificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Notification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Notification.prisma().query_raw(
            'SELECT * FROM Notification WHERE id = $1',
            'bacdaibgfa',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Notification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Notification.prisma().query_first(
            'SELECT * FROM Notification WHERE type = $1',
            enums.NotificationType.LOW_STOCK,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.NotificationCreateInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Notification record.

        Parameters
        ----------
        data
            Notification record data
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created Notification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Notification record from just the required fields
        notification = await Notification.prisma().create(
            data={
                # data to create a Notification record
                'type': enums.NotificationType.LOW_STOCK,
                'message': 'dchgibach',
                'priority': 'fchheijjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.NotificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Notification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Notification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Notification.prisma().create_many(
            data=[
                {
                    # data to create a Notification record
                    'type': enums.NotificationType.LOW_STOCK,
                    'message': 'cacjdfhejh',
                    'priority': 'bdbifjhbbi',
                },
                {
                    # data to create a Notification record
                    'type': enums.NotificationType.LOW_STOCK,
                    'message': 'cbccbbcdfb',
                    'priority': 'bacejedaca',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Notification record.

        Parameters
        ----------
        where
            Notification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The deleted Notification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().delete(
            where={
                'id': 'bhbhdahfaj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Notification record.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique(
            where={
                'id': 'bfjibceaec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Notification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Notification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The found Notification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().find_unique_or_raise(
            where={
                'id': 'ibhgcdbgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Notification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N results
        where
            Notification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Notification]
            The list of all Notification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Notification records
        notifications = await Notification.prisma().find_many(take=10)

        # find the first 5 Notification records ordered by the message field
        notifications = await Notification.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Notification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the priority field
        notification = await Notification.prisma().find_first(
            skip=1,
            order={
                'priority': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
        include: Optional[types.NotificationInclude] = None,
        order: Optional[Union[types.NotificationOrderByInput, List[types.NotificationOrderByInput]]] = None,
        distinct: Optional[List[types.NotificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Notification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Notification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Notification model
        order
            Order the returned Notification records by any field
        distinct
            Filter Notification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Notification
            The first Notification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Notification record ordered by the targetUser field
        notification = await Notification.prisma().find_first_or_raise(
            skip=1,
            order={
                'targetUser': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.NotificationUpdateInput,
        where: types.NotificationWhereUniqueInput,
        include: Optional[types.NotificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Notification record.

        Parameters
        ----------
        data
            Notification record data specifying what to update
        where
            Notification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The updated Notification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        notification = await Notification.prisma().update(
            where={
                'id': 'badaffhddg',
            },
            data={
                # data to update the Notification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.NotificationWhereUniqueInput,
        data: types.NotificationUpsertInput,
        include: Optional[types.NotificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Notification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Notification model

        Returns
        -------
        prisma.models.Notification
            The created or updated Notification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        notification = await Notification.prisma().upsert(
            where={
                'id': 'bbdbfcfihd',
            },
            data={
                'create': {
                    'id': 'bbdbfcfihd',
                    'type': enums.NotificationType.LOW_STOCK,
                    'message': 'cbccbbcdfb',
                    'priority': 'bacejedaca',
                },
                'update': {
                    'type': enums.NotificationType.LOW_STOCK,
                    'message': 'cbccbbcdfb',
                    'priority': 'bacejedaca',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.NotificationUpdateManyMutationInput,
        where: types.NotificationWhereInput,
    ) -> int:
        """Update multiple Notification records

        Parameters
        ----------
        data
            Notification data to update the selected Notification records to
        where
            Filter to select the Notification records to update

        Returns
        -------
        int
            The total number of Notification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Notification records
        total = await Notification.prisma().update_many(
            data={
                'metadata': Json({'cbagggbji': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'read': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.NotificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> types.NotificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.NotificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.NotificationWhereInput] = None,
        cursor: Optional[types.NotificationWhereUniqueInput] = None,
    ) -> Union[int, types.NotificationCountAggregateOutput]:
        """Count the number of Notification records present in the database

        Parameters
        ----------
        select
            Select the Notification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Notification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.NotificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Notification.prisma().count()

        # results: prisma.types.NotificationCountAggregateOutput
        results = await Notification.prisma().count(
            select={
                '_all': True,
                'readAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.NotificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.NotificationWhereInput] = None
    ) -> int:
        """Delete multiple Notification records.

        Parameters
        ----------
        where
            Optional Notification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Notification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Notification records
        total = await Notification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.NotificationScalarFieldKeysT'],
        *,
        where: Optional['types.NotificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.NotificationAvgAggregateInput'] = None,
        sum: Optional['types.NotificationSumAggregateInput'] = None,
        min: Optional['types.NotificationMinAggregateInput'] = None,
        max: Optional['types.NotificationMaxAggregateInput'] = None,
        having: Optional['types.NotificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.NotificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.NotificationScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.NotificationGroupByOutput']:
        """Group Notification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Notification fields to group records by
        where
            Notification filter to select records
        take
            Limit the maximum number of Notification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.NotificationGroupByOutput]
            A list of dictionaries representing the Notification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Notification records by createdAt values
        # and count how many records are in each group
        results = await Notification.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models